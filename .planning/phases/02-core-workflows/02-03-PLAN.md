---
phase: 02-core-workflows
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src-tauri/src/commands/p4.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Backend can execute p4 fstat and return file status data"
    - "Backend can execute p4 opened to get files in changelists"
    - "Backend can execute p4 edit, revert, submit commands"
    - "Backend emits events when file status changes"
  artifacts:
    - path: "src-tauri/src/commands/p4.rs"
      provides: "P4 operation commands"
      exports: ["p4_fstat", "p4_opened", "p4_edit", "p4_revert", "p4_submit", "p4_changes", "p4_sync"]
    - path: "src-tauri/src/commands/mod.rs"
      provides: "Command module exports"
      contains: "pub mod p4"
    - path: "src-tauri/src/lib.rs"
      provides: "Command registration"
      contains: "p4_fstat"
  key_links:
    - from: "src-tauri/src/commands/p4.rs"
      to: "tauri::AppHandle"
      via: "event emission"
      pattern: "app.emit"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/commands/p4.rs"
      via: "command registration"
      pattern: "invoke_handler.*p4_fstat"
---

<objective>
Create Rust backend commands for core Perforce operations: fstat, opened, edit, revert, submit, changes, and sync.

Purpose: The frontend needs structured data from p4 commands, not raw text. These commands parse p4 output into typed structs and emit events for real-time UI updates.

Output: New p4.rs module with typed Tauri commands for all core operations.
</objective>

<execution_context>
@./.claude/agents/gsd-planner.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-workflows/02-CONTEXT.md
@src-tauri/src/commands/process.rs
@src-tauri/src/commands/mod.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create P4 data structures and fstat command</name>
  <files>src-tauri/src/commands/p4.rs</files>
  <action>
Create new p4.rs file with Rust structs and the fstat command:

**Data structures (derive Serialize, Clone):**

```rust
#[derive(Debug, Clone, Serialize)]
pub struct P4FileInfo {
    pub depot_path: String,
    pub local_path: String,
    pub status: String,        // synced, checkedOut, added, deleted, modified, outOfDate
    pub action: Option<String>, // edit, add, delete, etc. (if opened)
    pub revision: i32,
    pub head_revision: i32,
    pub changelist: Option<i32>,
    pub file_type: String,
}

#[derive(Debug, Clone, Serialize)]
pub struct P4Changelist {
    pub id: i32,
    pub description: String,
    pub user: String,
    pub client: String,
    pub status: String,
    pub file_count: i32,
}
```

**p4_fstat command:**

```rust
#[tauri::command]
pub async fn p4_fstat(paths: Vec<String>) -> Result<Vec<P4FileInfo>, String>
```

- Execute: `p4 -ztag fstat <paths>` (or `p4 -ztag fstat ...` for all files)
- Parse -ztag output format (tagged output, one field per line)
- Map p4 fields to P4FileInfo:
  - depotFile -> depot_path
  - clientFile -> local_path
  - headRev -> head_revision
  - haveRev -> revision
  - action -> action (if present, file is opened)
  - change -> changelist
  - headType -> file_type
- Derive status from fields:
  - action present -> checkedOut (or added/deleted based on action)
  - haveRev < headRev -> outOfDate
  - haveRev == headRev, no action -> synced
- Return Vec<P4FileInfo>
- Handle case where p4 fstat returns error (file not in depot)
  </action>
  <verify>File compiles (syntax check with IDE or cargo check when available)</verify>
  <done>p4_fstat command parses p4 output into structured P4FileInfo vec</done>
</task>

<task type="auto">
  <name>Task 2: Add opened, changes, edit, revert commands</name>
  <files>src-tauri/src/commands/p4.rs</files>
  <action>
Add remaining P4 operation commands to p4.rs:

**p4_opened command:**
```rust
#[tauri::command]
pub async fn p4_opened() -> Result<Vec<P4FileInfo>, String>
```
- Execute: `p4 -ztag opened`
- Parse output to get all files opened by user
- Returns files grouped by changelist

**p4_changes command:**
```rust
#[tauri::command]
pub async fn p4_changes(status: Option<String>) -> Result<Vec<P4Changelist>, String>
```
- Execute: `p4 -ztag changes -s pending` (or -s submitted based on status param)
- Parse changelist info
- Add -u (current user) and -c (current client) flags

**p4_edit command:**
```rust
#[tauri::command]
pub async fn p4_edit(paths: Vec<String>, changelist: Option<i32>, app: tauri::AppHandle) -> Result<Vec<P4FileInfo>, String>
```
- Execute: `p4 edit -c <changelist> <paths>` (or default CL if none)
- Parse result to confirm which files were opened
- Emit 'file-status-changed' event via app.emit() for each file
- Return updated file info

**p4_revert command:**
```rust
#[tauri::command]
pub async fn p4_revert(paths: Vec<String>, app: tauri::AppHandle) -> Result<Vec<String>, String>
```
- Execute: `p4 revert <paths>`
- Parse result to confirm reverted files
- Emit 'file-status-changed' event for each file (status -> synced)
- Return list of reverted depot paths

Use std::process::Command for execution (consistent with process.rs).
All commands should be async (even if internally synchronous) for consistency.
  </action>
  <verify>File has no syntax errors</verify>
  <done>p4_opened, p4_changes, p4_edit, p4_revert commands implemented</done>
</task>

<task type="auto">
  <name>Task 3: Add submit and sync commands, wire up module</name>
  <files>src-tauri/src/commands/p4.rs, src-tauri/src/commands/mod.rs, src-tauri/src/lib.rs</files>
  <action>
**Add p4_submit command to p4.rs:**
```rust
#[tauri::command]
pub async fn p4_submit(
    changelist: i32,
    description: Option<String>,
    app: tauri::AppHandle
) -> Result<i32, String>
```
- If description provided, first run `p4 change -o <changelist>` to get form, update description, pipe to `p4 change -i`
- Execute: `p4 submit -c <changelist>`
- Parse result to get submitted changelist number
- Emit 'changelist-submitted' event
- Return submitted changelist number

**Add p4_sync command to p4.rs:**
```rust
#[tauri::command]
pub async fn p4_sync(
    paths: Vec<String>,
    on_progress: tauri::ipc::Channel<SyncProgress>,
    state: tauri::State<'_, ProcessManager>,
    app: tauri::AppHandle
) -> Result<String, String>
```
- Spawn p4 sync process (use ProcessManager like spawn_p4_command)
- Parse each output line for progress:
  - "//depot/path#rev - updating/adding/deleting local/path" -> emit SyncProgress
- Stream progress via Channel
- On conflict line, include conflict info in progress event
- Return process ID for cancellation

**SyncProgress struct:**
```rust
#[derive(Clone, Serialize)]
pub struct SyncProgress {
    pub depot_path: String,
    pub action: String,  // updating, adding, deleting, can't clobber
    pub revision: i32,
    pub is_conflict: bool,
}
```

**Wire up in mod.rs:**
Add `pub mod p4;` to src-tauri/src/commands/mod.rs

**Register in lib.rs:**
Add all p4 commands to invoke_handler:
- p4_fstat
- p4_opened
- p4_changes
- p4_edit
- p4_revert
- p4_submit
- p4_sync

Import: `use crate::commands::p4::*;`
  </action>
  <verify>mod.rs exports p4 module, lib.rs registers commands</verify>
  <done>All P4 commands registered and module properly wired</done>
</task>

</tasks>

<verification>
- p4.rs contains all command functions
- mod.rs exports p4 module
- lib.rs registers all 7 new commands
- Commands use -ztag flag for parseable output
- Event emission present in edit, revert, submit commands
</verification>

<success_criteria>
- Backend provides typed Tauri commands for all core P4 operations
- Commands emit events for real-time UI updates
- Sync command supports streaming progress and cancellation
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-workflows/02-03-SUMMARY.md`
</output>
