---
phase: 13-workspace-stream-switching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/commands/p4.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
  - src/lib/tauri.ts
autonomous: true

must_haves:
  truths:
    - "Frontend can call p4_list_streams and receive structured stream data"
    - "Frontend can call p4_get_client_spec and receive structured client spec"
    - "Frontend can call p4_update_client_stream and it modifies the client's Stream field"
  artifacts:
    - path: "src-tauri/src/commands/p4.rs"
      provides: "Three new Rust commands: p4_list_streams, p4_get_client_spec, p4_update_client_stream"
    - path: "src/lib/tauri.ts"
      provides: "TypeScript invoke wrappers and types for new commands"
  key_links:
    - from: "src/lib/tauri.ts"
      to: "src-tauri/src/commands/p4.rs"
      via: "Tauri invoke bridge"
      pattern: "invoke.*p4_list_streams|p4_get_client_spec|p4_update_client_stream"
---

<objective>
Add three new Rust backend commands for workspace/stream switching: list streams, get client spec, and update client stream.

Purpose: Backend foundation for all Phase 13 UI components — switchers and client spec viewer need these commands.
Output: Three new Tauri commands callable from frontend with TypeScript types.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-workspace-stream-switching/13-RESEARCH.md
@src-tauri/src/commands/p4.rs
@src-tauri/src/commands/mod.rs
@src-tauri/src/lib.rs
@src/lib/tauri.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add three new Rust commands for stream/workspace management</name>
  <files>src-tauri/src/commands/p4.rs, src-tauri/src/commands/mod.rs, src-tauri/src/lib.rs</files>
  <action>
Add three new commands to p4.rs following the existing pattern (apply_connection_args, -ztag parsing, Result<T, String> returns):

1. **p4_list_streams** — `p4 -ztag streams`
   - Args: server: Option<String>, user: Option<String>, client: Option<String>
   - Returns: Vec<P4Stream> where P4Stream has: stream (full path like //depot/main), name (display name), parent (Option<String>), stream_type (String — mainline/development/release), description (String)
   - Parser: parse_ztag_streams — same pattern as parse_ztag_clients. Fields from -ztag output: Stream, Name, Parent, Type, desc
   - Note: P4 uses "Type" but Rust reserves `type` — use `stream_type` with #[serde(rename = "type")] or just name the field `stream_type`

2. **p4_get_client_spec** — `p4 -ztag client -o <workspace>`
   - Args: workspace: String, server: Option<String>, user: Option<String>
   - Returns: P4ClientSpec with fields: client (String), root (String), stream (Option<String>), owner (String), description (String), view (Vec<String>), options (String), host (String), submit_options (String)
   - Parser: parse_ztag_client_spec — -ztag output has View0, View1, View2... for view mappings. Collect all ViewN fields into a vec.
   - Note: Don't pass client arg (-c) since we're querying a specific workspace name, not using it as context

3. **p4_update_client_stream** — `p4 client -o` then modify Stream field, then `p4 client -i`
   - Args: workspace: String, new_stream: String, server: Option<String>, user: Option<String>
   - Implementation: Get raw form with `p4 client -o <workspace>` (WITHOUT -ztag — need the form format), replace the `Stream:` line with new stream value, pipe modified form to `p4 client -i` via stdin
   - Returns: Result<String, String> — success message or error
   - IMPORTANT: Use Stdio::piped() for stdin on the `client -i` command. Drop stdin handle before calling wait_with_output() to signal EOF.

Register all three in mod.rs (pub use) and lib.rs (generate_handler! macro).
  </action>
  <verify>Run `cargo check` in src-tauri/ to verify compilation: `cd src-tauri && cargo check`</verify>
  <done>All three commands compile and are registered in the Tauri invoke handler</done>
</task>

<task type="auto">
  <name>Task 2: Add TypeScript invoke wrappers and types</name>
  <files>src/lib/tauri.ts</files>
  <action>
Add to src/lib/tauri.ts following existing patterns (invoke<T>('command_name', { args })):

1. **P4Stream interface:**
   ```typescript
   export interface P4Stream {
     stream: string;       // Full path: //depot/main
     name: string;         // Display name
     parent: string | null;
     stream_type: string;  // mainline, development, release
     description: string;
   }
   ```

2. **P4ClientSpec interface:**
   ```typescript
   export interface P4ClientSpec {
     client: string;
     root: string;
     stream: string | null;
     owner: string;
     description: string;
     view: string[];
     options: string;
     host: string;
     submit_options: string;
   }
   ```

3. **invokeP4ListStreams** — calls p4_list_streams, returns Promise<P4Stream[]>
4. **invokeP4GetClientSpec** — calls p4_get_client_spec, takes workspace: string, returns Promise<P4ClientSpec>
5. **invokeP4UpdateClientStream** — calls p4_update_client_stream, takes workspace: string and newStream: string, returns Promise<string>

All three accept optional server/user/client connection args matching existing patterns.
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compiles</verify>
  <done>All three invoke wrappers and types exist and compile without errors</done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` — Rust compiles
2. `npx tsc --noEmit` — TypeScript compiles
3. Grep for all three command names in lib.rs generate_handler
</verification>

<success_criteria>
- Three Rust commands (p4_list_streams, p4_get_client_spec, p4_update_client_stream) compile and are registered
- TypeScript types and invoke wrappers exist for all three
- Follows existing patterns (apply_connection_args, -ztag parsing, Result returns)
</success_criteria>

<output>
After completion, create `.planning/phases/13-workspace-stream-switching/13-01-SUMMARY.md`
</output>
