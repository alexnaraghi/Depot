---
phase: 15-resolve-workflow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/commands/p4.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Rust backend can detect unresolved files via p4 fstat -Ru -Or"
    - "Rust backend can accept resolve with theirs/yours/merge modes"
    - "Rust backend can launch P4MERGE and wait for exit via spawn_blocking"
    - "Rust backend can extract base/theirs revisions to temp files for merge tool"
  artifacts:
    - path: "src-tauri/src/commands/p4.rs"
      provides: "p4_fstat_unresolved, p4_resolve_accept, launch_merge_tool commands"
      contains: "p4_fstat_unresolved"
    - path: "src-tauri/src/lib.rs"
      provides: "Command registration for new resolve commands"
      contains: "p4_fstat_unresolved"
  key_links:
    - from: "p4_fstat_unresolved"
      to: "p4 fstat -Ru -Or"
      via: "Command::new(p4) with -ztag fstat -Ru -Or"
      pattern: "fstat.*-Ru"
    - from: "launch_merge_tool"
      to: "tokio::task::spawn_blocking"
      via: "spawn_blocking wrapping std::process::Command"
      pattern: "spawn_blocking"
---

<objective>
Add Rust backend commands for the resolve workflow: detecting unresolved files, accepting resolutions (theirs/yours/merge), and launching external merge tools with blocking wait.

Purpose: Provides the Tauri command layer that the frontend resolve UI will invoke. Without these commands, no resolve operations can be triggered from the app.
Output: Three new Tauri commands registered and callable from the frontend.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-resolve-workflow/15-RESEARCH.md

@src-tauri/src/commands/p4.rs — Existing p4 commands (p4_resolve_preview, launch_diff_tool, p4_print_to_file patterns)
@src-tauri/src/lib.rs — Command registration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add p4_fstat_unresolved and p4_resolve_accept commands</name>
  <files>src-tauri/src/commands/p4.rs</files>
  <action>
Add two new Tauri commands to p4.rs:

1. `p4_fstat_unresolved` — Detects files needing resolution.
   - Run `p4 -ztag fstat -Ru -Or //...` with connection args via `apply_connection_args`
   - Parse ztag output for fields: depotFile, clientFile, headRev, haveRev, unresolved, resolveAction (look for resolveAction0 field)
   - Return a new struct `P4UnresolvedFile` with fields: `depot_path: String`, `local_path: String`, `head_rev: i32`, `have_rev: i32`, `resolve_action: String` (values like "merge", "copy from", etc.)
   - Use `#[serde(rename_all = "camelCase")]` on the struct
   - Handle "no such file(s)" as empty vec (same pattern as p4_dirs)
   - If stderr contains error text but stdout has data, still parse stdout (p4 fstat may emit warnings alongside results)

2. `p4_resolve_accept` — Executes quick resolve.
   - Parameters: `file_path: String` (depot path), `mode: String` ("theirs", "yours", "merge"), plus connection args
   - Map mode to flag: "theirs" -> "-at", "yours" -> "-ay", "merge" -> "-am"
   - Run `p4 resolve {flag} {file_path}` with connection args
   - Return stdout as String on success, stderr as error on failure
   - Invalid mode returns Err immediately

Follow existing command patterns: async fn, `#[tauri::command]`, `apply_connection_args`, `Command::new("p4")`.
  </action>
  <verify>Run `cargo check` in src-tauri directory to verify compilation.</verify>
  <done>Two new commands compile: p4_fstat_unresolved returns Vec of unresolved file info, p4_resolve_accept executes quick resolve with theirs/yours/merge modes.</done>
</task>

<task type="auto">
  <name>Task 2: Add launch_merge_tool command with blocking wait and temp file extraction</name>
  <files>src-tauri/src/commands/p4.rs, src-tauri/src/lib.rs</files>
  <action>
Add `launch_merge_tool` Tauri command to p4.rs:

- Parameters: `depot_path: String`, `local_path: String`, connection args (server, user, client)
- Step 1: Check `P4MERGE` env var, fallback to `MERGE`. If neither set, return descriptive error: "P4MERGE environment variable not set. Set P4MERGE to your merge tool path (e.g., C:\\Program Files\\Perforce\\p4merge.exe)."
- Step 2: Get base and theirs file contents to temp files. Use existing `p4_print_to_file` logic as reference:
  - Run `p4 -ztag fstat -Or {depot_path}` to get resolveBaseRev and resolveEndFromRev (or parse from resolveAction fields)
  - Actually simpler: run `p4 resolve -o {depot_path}` which outputs the base/theirs/yours/result paths. BUT this is interactive. Instead:
  - Run `p4 -ztag fstat {depot_path}` and extract `resolveBaseFile`, `resolveBaseRev`, `resolveFromFile0`, `resolveEndFromRev0` fields
  - Use `p4 print -o {temp_path} {resolveBaseFile}#{resolveBaseRev}` to extract base to a temp file
  - Use `p4 print -o {temp_path} {resolveFromFile0}#{resolveEndFromRev0}` to extract theirs to a temp file
  - Use `std::env::temp_dir()` for temp file location with unique names (include timestamp or random suffix)
- Step 3: Spawn merge tool with `tokio::task::spawn_blocking`:
  ```rust
  let exit_code = tokio::task::spawn_blocking(move || {
      let status = Command::new(&merge_tool)
          .args([&base_temp, &theirs_temp, &local_path, &local_path])
          .status()
          .map_err(|e| format!("Failed to launch merge tool: {}", e))?;
      Ok::<i32, String>(status.code().unwrap_or(-1))
  }).await.map_err(|e| format!("Task failed: {}", e))??;
  ```
- Step 4: Clean up temp files (best effort, ignore cleanup errors)
- Return the exit code as i32

Register all three new commands in lib.rs: add `commands::p4_fstat_unresolved`, `commands::p4_resolve_accept`, `commands::launch_merge_tool` to the invoke_handler list (find the existing pattern with `commands::launch_diff_tool` and add nearby).
  </action>
  <verify>Run `cargo check` in src-tauri directory. All three commands must compile and be registered.</verify>
  <done>launch_merge_tool command compiles, extracts base/theirs to temp files, spawns P4MERGE with spawn_blocking, waits for exit, cleans up temps, returns exit code. All three new commands registered in lib.rs.</done>
</task>

</tasks>

<verification>
1. `cargo check` passes in src-tauri directory with zero errors
2. Three new commands exist: p4_fstat_unresolved, p4_resolve_accept, launch_merge_tool
3. All commands use apply_connection_args pattern
4. launch_merge_tool uses tokio::task::spawn_blocking (not bare spawn)
5. P4UnresolvedFile struct has camelCase serde rename
</verification>

<success_criteria>
Backend resolve commands compile and are registered. p4_fstat_unresolved detects unresolved files, p4_resolve_accept handles quick resolve, launch_merge_tool spawns P4MERGE with blocking wait and temp file management.
</success_criteria>

<output>
After completion, create `.planning/phases/15-resolve-workflow/15-01-SUMMARY.md`
</output>
