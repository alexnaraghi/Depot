---
phase: 01-non-blocking-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/store/operation.ts
  - src/hooks/useP4Command.ts
  - src/lib/tauri.ts
  - src/main.tsx
autonomous: true

must_haves:
  truths:
    - "Frontend can track operation status (idle, running, cancelling)"
    - "Frontend can track progress percentage and current message"
    - "React Query provides abort signal integration for cancellation"
    - "Cancel action triggers both frontend query cancel and backend process kill"
  artifacts:
    - path: "src/store/operation.ts"
      provides: "Zustand store for operation state"
      exports: ["useOperationStore", "OperationStatus"]
    - path: "src/hooks/useP4Command.ts"
      provides: "React hook wrapping TanStack Query for p4 commands"
      exports: ["useP4Command", "useP4StreamingCommand"]
    - path: "src/lib/tauri.ts"
      provides: "Type-safe Tauri invoke wrappers"
      exports: ["invokeP4Command", "invokeSpawnP4", "invokeKillProcess"]
    - path: "src/main.tsx"
      provides: "App entry with QueryClientProvider"
      contains: "QueryClientProvider"
  key_links:
    - from: "src/hooks/useP4Command.ts"
      to: "src/lib/tauri.ts"
      via: "invokeP4Command import"
      pattern: "import.*tauri"
    - from: "src/hooks/useP4Command.ts"
      to: "src/store/operation.ts"
      via: "useOperationStore"
      pattern: "useOperationStore"
    - from: "src/main.tsx"
      to: "@tanstack/react-query"
      via: "QueryClientProvider"
      pattern: "QueryClientProvider"
---

<objective>
Implement frontend state management and React hooks for async p4 command execution

Purpose: Provide React components with clean APIs for executing, tracking, and cancelling p4 operations
Output: Zustand store for operation state, TanStack Query hooks for p4 commands with cancellation support
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-non-blocking-foundation/01-RESEARCH.md
@.planning/phases/01-non-blocking-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand store for operation status tracking</name>
  <files>
    src/store/operation.ts
  </files>
  <action>
    Create src/store/ directory.

    Create src/store/operation.ts with Zustand store for tracking operation state:

    ```typescript
    import { create } from 'zustand';

    export type OperationStatus = 'idle' | 'running' | 'cancelling' | 'error' | 'success';

    export interface Operation {
      id: string;
      command: string;
      status: OperationStatus;
      message: string;
      progress?: number; // 0-100, undefined = indeterminate
      processId?: string; // Backend process ID for cancellation
      startedAt: number;
      error?: string;
    }

    export interface OutputLine {
      line: string;
      isStderr: boolean;
      timestamp: number;
    }

    interface OperationState {
      // Current operation (one at a time per CONTEXT.md)
      currentOperation: Operation | null;

      // Output lines for collapsible panel
      outputLines: OutputLine[];

      // Actions
      startOperation: (id: string, command: string, processId?: string) => void;
      updateProgress: (progress: number, message?: string) => void;
      updateMessage: (message: string) => void;
      setProcessId: (processId: string) => void;
      setCancelling: () => void;
      completeOperation: (success: boolean, error?: string) => void;
      clearOperation: () => void;

      // Output actions
      addOutputLine: (line: string, isStderr: boolean) => void;
      clearOutput: () => void;
    }

    export const useOperationStore = create<OperationState>((set, get) => ({
      currentOperation: null,
      outputLines: [],

      startOperation: (id, command, processId) => {
        set({
          currentOperation: {
            id,
            command,
            status: 'running',
            message: `Running: p4 ${command}`,
            processId,
            startedAt: Date.now(),
          },
          outputLines: [], // Clear previous output
        });
      },

      updateProgress: (progress, message) => {
        const current = get().currentOperation;
        if (current) {
          set({
            currentOperation: {
              ...current,
              progress,
              message: message ?? current.message,
            },
          });
        }
      },

      updateMessage: (message) => {
        const current = get().currentOperation;
        if (current) {
          set({
            currentOperation: { ...current, message },
          });
        }
      },

      setProcessId: (processId) => {
        const current = get().currentOperation;
        if (current) {
          set({
            currentOperation: { ...current, processId },
          });
        }
      },

      setCancelling: () => {
        const current = get().currentOperation;
        if (current) {
          set({
            currentOperation: {
              ...current,
              status: 'cancelling',
              message: 'Cancelling...',
            },
          });
        }
      },

      completeOperation: (success, error) => {
        const current = get().currentOperation;
        if (current) {
          set({
            currentOperation: {
              ...current,
              status: success ? 'success' : 'error',
              message: success ? 'Completed' : (error ?? 'Failed'),
              error,
              progress: success ? 100 : current.progress,
            },
          });

          // Auto-clear after success (status bar can show briefly)
          if (success) {
            setTimeout(() => {
              if (get().currentOperation?.id === current.id) {
                set({ currentOperation: null });
              }
            }, 2000);
          }
        }
      },

      clearOperation: () => {
        set({ currentOperation: null });
      },

      addOutputLine: (line, isStderr) => {
        set((state) => ({
          outputLines: [
            ...state.outputLines,
            { line, isStderr, timestamp: Date.now() },
          ],
        }));
      },

      clearOutput: () => {
        set({ outputLines: [] });
      },
    }));
    ```

    Key design decisions per CONTEXT.md:
    - One operation at a time (queue operations, show "operation in progress")
    - Progress can be undefined (indeterminate spinner) or 0-100 (progress bar)
    - Tracks processId for backend cancellation
    - Output lines stored for collapsible panel
    - Auto-clears success after 2 seconds
  </action>
  <verify>
    grep "useOperationStore" src/store/operation.ts && grep "OperationStatus" src/store/operation.ts
  </verify>
  <done>Zustand store with operation status, progress, and output line tracking</done>
</task>

<task type="auto">
  <name>Task 2: Create type-safe Tauri invoke wrappers</name>
  <files>
    src/lib/tauri.ts
  </files>
  <action>
    Create src/lib/ directory if not exists.

    Create src/lib/tauri.ts with typed wrappers for Tauri commands:

    ```typescript
    import { invoke, Channel } from '@tauri-apps/api/core';

    // Types matching Rust structs
    export interface OutputLine {
      line: string;
      is_stderr: boolean;
    }

    export interface ProcessResult {
      exit_code: number | null;
      success: boolean;
    }

    /**
     * Execute a short p4 command and wait for result.
     * Use for quick commands like 'p4 info', 'p4 client'.
     */
    export async function invokeP4Command(args: string[]): Promise<string> {
      return invoke<string>('p4_command', { args });
    }

    /**
     * Spawn a long-running p4 command with streaming output.
     * Use for commands like 'p4 sync' that produce lots of output.
     * Returns process ID for cancellation.
     */
    export async function invokeSpawnP4(
      args: string[],
      onOutput: (line: OutputLine) => void
    ): Promise<string> {
      const channel = new Channel<OutputLine>();
      channel.onmessage = onOutput;

      return invoke<string>('spawn_p4_command', {
        args,
        onOutput: channel,
      });
    }

    /**
     * Kill a tracked process by ID.
     * Returns true if process was found and killed.
     */
    export async function invokeKillProcess(processId: string): Promise<boolean> {
      return invoke<boolean>('kill_process', { processId });
    }

    /**
     * Kill all tracked processes.
     * Called automatically on app close, but can be called manually.
     */
    export async function invokeKillAllProcesses(): Promise<void> {
      return invoke<void>('kill_all_processes');
    }
    ```

    Types match Rust struct names (with snake_case -> camelCase conversion where Tauri handles it).
  </action>
  <verify>
    grep "invokeP4Command" src/lib/tauri.ts && grep "invokeSpawnP4" src/lib/tauri.ts && grep "invokeKillProcess" src/lib/tauri.ts
  </verify>
  <done>Type-safe Tauri invoke wrappers for all process commands</done>
</task>

<task type="auto">
  <name>Task 3: Create TanStack Query hooks for p4 commands</name>
  <files>
    src/hooks/useP4Command.ts
    src/main.tsx
  </files>
  <action>
    Create src/hooks/ directory.

    Create src/hooks/useP4Command.ts:

    ```typescript
    import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
    import { useCallback } from 'react';
    import { invokeP4Command, invokeSpawnP4, invokeKillProcess, OutputLine } from '@/lib/tauri';
    import { useOperationStore } from '@/store/operation';

    /**
     * Hook for short p4 commands that return a result.
     * Good for: p4 info, p4 client, p4 where
     */
    export function useP4Query(command: string, args: string[] = [], options?: {
      enabled?: boolean;
      refetchOnWindowFocus?: boolean;
    }) {
      const fullArgs = [command, ...args];

      return useQuery({
        queryKey: ['p4', command, ...args],
        queryFn: async () => {
          return invokeP4Command(fullArgs);
        },
        enabled: options?.enabled ?? true,
        refetchOnWindowFocus: options?.refetchOnWindowFocus ?? false,
      });
    }

    /**
     * Hook for executing p4 commands with operation tracking.
     * Good for: any command that should show in status bar
     */
    export function useP4Command() {
      const queryClient = useQueryClient();
      const {
        currentOperation,
        startOperation,
        setProcessId,
        updateMessage,
        setCancelling,
        completeOperation,
        addOutputLine,
      } = useOperationStore();

      const execute = useCallback(async (
        command: string,
        args: string[] = [],
        options?: {
          streaming?: boolean;
        }
      ): Promise<string | void> => {
        // Check if operation already running
        if (currentOperation && currentOperation.status === 'running') {
          throw new Error('Another operation is already in progress');
        }

        const operationId = `${command}-${Date.now()}`;
        const fullArgs = [command, ...args];

        startOperation(operationId, fullArgs.join(' '));

        try {
          if (options?.streaming) {
            // Long-running command with streaming output
            const processId = await invokeSpawnP4(fullArgs, (output: OutputLine) => {
              addOutputLine(output.line, output.is_stderr);
              // Update message with last line (simple progress indicator)
              if (!output.is_stderr) {
                updateMessage(output.line);
              }
            });

            setProcessId(processId);

            // Note: For streaming commands, completion is detected by process exit
            // which we'd handle via a completion channel. For now, mark as complete
            // after spawn returns (caller handles waiting if needed).
            completeOperation(true);
            return processId;
          } else {
            // Short command, wait for result
            const result = await invokeP4Command(fullArgs);
            completeOperation(true);
            return result;
          }
        } catch (error) {
          completeOperation(false, String(error));
          throw error;
        }
      }, [currentOperation, startOperation, setProcessId, updateMessage, completeOperation, addOutputLine]);

      const cancel = useCallback(async () => {
        if (!currentOperation?.processId) return;

        setCancelling();

        try {
          await invokeKillProcess(currentOperation.processId);
          completeOperation(false, 'Cancelled by user');
        } catch (error) {
          completeOperation(false, `Cancel failed: ${error}`);
        }
      }, [currentOperation, setCancelling, completeOperation]);

      return {
        execute,
        cancel,
        isRunning: currentOperation?.status === 'running',
        isCancelling: currentOperation?.status === 'cancelling',
        canCancel: !!currentOperation?.processId && currentOperation.status === 'running',
      };
    }

    /**
     * Hook specifically for streaming commands with progress tracking.
     * Good for: p4 sync (long-running with output)
     */
    export function useP4StreamingCommand() {
      const { execute, cancel, isRunning, isCancelling, canCancel } = useP4Command();

      const executeStreaming = useCallback(
        (command: string, args: string[] = []) => {
          return execute(command, args, { streaming: true });
        },
        [execute]
      );

      return {
        execute: executeStreaming,
        cancel,
        isRunning,
        isCancelling,
        canCancel,
      };
    }
    ```

    Update src/main.tsx to add QueryClientProvider:

    ```typescript
    import React from 'react';
    import ReactDOM from 'react-dom/client';
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
    import App from './App';
    import './index.css';

    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retry: 1,
          refetchOnWindowFocus: false,
        },
      },
    });

    ReactDOM.createRoot(document.getElementById('root')!).render(
      <React.StrictMode>
        <QueryClientProvider client={queryClient}>
          <App />
        </QueryClientProvider>
      </React.StrictMode>
    );
    ```

    Also ensure tsconfig.json has path aliases configured:

    ```json
    {
      "compilerOptions": {
        "baseUrl": ".",
        "paths": {
          "@/*": ["./src/*"]
        }
      }
    }
    ```

    And vite.config.ts:

    ```typescript
    import { defineConfig } from 'vite';
    import react from '@vitejs/plugin-react';
    import path from 'path';

    export default defineConfig({
      plugins: [react()],
      resolve: {
        alias: {
          '@': path.resolve(__dirname, './src'),
        },
      },
    });
    ```
  </action>
  <verify>
    grep "useP4Command" src/hooks/useP4Command.ts && grep "QueryClientProvider" src/main.tsx && grep "invokeKillProcess" src/hooks/useP4Command.ts
  </verify>
  <done>TanStack Query hooks with operation tracking and cancellation support wired to Zustand store</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript check:
   ```bash
   npm run build
   ```
   Should complete without type errors.

2. Import verification:
   - src/hooks/useP4Command.ts imports from @/lib/tauri and @/store/operation
   - src/main.tsx has QueryClientProvider wrapping App

3. Store functionality (unit test or manual):
   - useOperationStore can startOperation, updateProgress, completeOperation
   - Operation status transitions work correctly
</verification>

<success_criteria>
- Zustand store tracks operation status, progress, and output lines
- Type-safe Tauri invoke wrappers match Rust command signatures
- useP4Command hook integrates Zustand + TanStack Query
- Cancel action calls both setCancelling and invokeKillProcess
- QueryClientProvider wraps App in main.tsx
- Path aliases (@/) configured in tsconfig and vite.config
</success_criteria>

<output>
After completion, create `.planning/phases/01-non-blocking-foundation/01-03-SUMMARY.md`
</output>
