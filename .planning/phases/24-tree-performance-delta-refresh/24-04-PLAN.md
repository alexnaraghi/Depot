---
phase: 24-tree-performance-delta-refresh
plan: 04
type: execute
wave: 3
depends_on: [24-02, 24-03]
files_modified:
  - src/components/FileTree/useFileTree.ts
autonomous: true

must_haves:
  truths:
    - "Auto-refresh queries only opened files on fast interval (30s default)"
    - "Full workspace refresh occurs on slow interval (5min default)"
    - "Auto-refresh pauses when window loses focus"
    - "Delta refresh merges incrementally using threshold heuristic"
    - "Tree updates don't cause flicker or scroll position loss"
  artifacts:
    - path: "src/components/FileTree/useFileTree.ts"
      provides: "Two-tier auto-refresh with incremental merge"
      contains: "deltaRefreshInterval"
  key_links:
    - from: "src/components/FileTree/useFileTree.ts"
      to: "src/lib/tauri.ts"
      via: "invokeP4FstatOpened for delta refresh"
      pattern: "invokeP4FstatOpened"
    - from: "src/components/FileTree/useFileTree.ts"
      to: "src/utils/treeBuilder.ts"
      via: "incrementalTreeUpdate for structural sharing"
      pattern: "incrementalTreeUpdate"
---

<objective>
Integrate two-tier auto-refresh into useFileTree with incremental updates.

Purpose: File tree should auto-refresh efficiently. Fast refresh (30s) queries only opened files, slow refresh (5min) queries full workspace. When delta results arrive, use incremental tree update if <10% changed, otherwise full rebuild. This keeps the UI responsive while data stays fresh.
Output: useFileTree with two separate refetch intervals, incremental merge logic, focus-aware refresh
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-tree-performance-delta-refresh/24-CONTEXT.md
@.planning/phases/24-tree-performance-delta-refresh/24-RESEARCH.md
@.planning/phases/24-tree-performance-delta-refresh/24-01-SUMMARY.md
@.planning/phases/24-tree-performance-delta-refresh/24-02-SUMMARY.md
@.planning/phases/24-tree-performance-delta-refresh/24-03-SUMMARY.md
@src/components/FileTree/useFileTree.ts
@src/components/ChangelistPanel/useChangelists.ts
@src/hooks/useWindowFocus.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add two-tier auto-refresh queries</name>
  <files>
    src/components/FileTree/useFileTree.ts
  </files>
  <action>
    Restructure useFileTree to support two-tier refresh following useChangelists.ts pattern.

    1. Add imports at top:
       ```typescript
       import { useWindowFocus } from '@/hooks/useWindowFocus';
       import { getDeltaRefreshInterval, getFullRefreshInterval } from '@/lib/settings';
       import {
         invokeP4FstatStream,
         invokeP4Info,
         invokeP4FstatOpened,
         P4FileInfo,
         FstatStreamBatch,
         addFilesToIndex,
         clearFileIndex,
       } from '@/lib/tauri';
       import {
         buildFileTree,
         incrementalTreeUpdate,
         shouldUseIncrementalUpdate,
         createChangeMap,
         mergeDeltaFiles,
       } from '@/utils/treeBuilder';
       ```

    2. Add state for refresh intervals and window focus:
       ```typescript
       const isWindowFocused = useWindowFocus();

       // Load refresh intervals from settings
       const [deltaInterval, setDeltaInterval] = useState<number>(30000);
       const [fullInterval, setFullInterval] = useState<number>(300000);

       useEffect(() => {
         getDeltaRefreshInterval().then(setDeltaInterval);
         getFullRefreshInterval().then(setFullInterval);
       }, []);

       // Auto-refresh is active when connected, not streaming, window focused, and interval > 0
       const isDeltaRefreshActive =
         isConnected && !isStreaming && isWindowFocused && deltaInterval > 0;
       const isFullRefreshActive =
         isConnected && !isStreaming && isWindowFocused && fullInterval > 0;
       ```

    3. Add delta refresh query (fast, opened files only):
       ```typescript
       // Fast refresh: query only opened files every 30s
       const { data: openedFilesData } = useQuery({
         queryKey: ['p4', 'fstat', 'opened', p4port, p4user, p4client],
         queryFn: async () => {
           const verbose = await getVerboseLogging();
           if (verbose) addOutputLine('p4 fstat (opened files for delta refresh)', false);
           const result = await invokeP4FstatOpened();
           if (verbose) addOutputLine(`... returned ${result.length} opened items`, false);
           return result.map(mapP4FileInfo);
         },
         enabled: isDeltaRefreshActive && rootPath !== null,
         staleTime: deltaInterval / 2, // Allow refetch after half the interval
         refetchInterval: isDeltaRefreshActive ? deltaInterval : false,
         refetchOnWindowFocus: false, // We handle focus ourselves
       });
       ```

    4. Modify existing full workspace query to use slow interval:
       - Change the existing streaming query's refetchInterval:
         ```typescript
         refetchInterval: isFullRefreshActive ? fullInterval : false,
         ```
       - Keep structuralSharing: false for streaming (required)

    5. Add reference for previous tree to enable incremental updates:
       ```typescript
       const prevTreeRef = useRef<FileTreeNode[]>([]);
       const prevFilesRef = useRef<Map<string, P4File>>(new Map());
       ```
  </action>
  <verify>
    TypeScript compiles: npm run build
    grep "deltaRefreshInterval\|openedFilesData" src/components/FileTree/useFileTree.ts
    grep "isWindowFocused" src/components/FileTree/useFileTree.ts
  </verify>
  <done>
    useFileTree loads delta and full refresh intervals from settings
    Delta refresh query (30s) fetches only opened files via invokeP4FstatOpened
    Full refresh (5min) uses existing streaming fstat
    Both queries respect window focus state (pause when blurred)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement incremental merge logic</name>
  <files>
    src/components/FileTree/useFileTree.ts
  </files>
  <action>
    Add effect to merge delta results incrementally when they arrive.

    1. Add effect to process delta refresh results:
       ```typescript
       // Process delta refresh results
       useEffect(() => {
         if (!openedFilesData || openedFilesData.length === 0) return;
         if (prevFilesRef.current.size === 0) return; // No existing data to merge with

         const files = useFileTreeStore.getState().files;

         // Create change map to identify actual changes
         const changeMap = createChangeMap(files, openedFilesData);

         if (changeMap.size === 0) {
           // No actual changes detected
           return;
         }

         // Decide: incremental update or merge and let full refresh rebuild
         if (shouldUseIncrementalUpdate(files.size, changeMap.size)) {
           // Incremental: update tree in place with structural sharing
           const currentTree = prevTreeRef.current;
           if (currentTree.length > 0) {
             const updatedTree = incrementalTreeUpdate(currentTree, changeMap);
             prevTreeRef.current = updatedTree;

             // Merge files into store
             const mergedFiles = mergeDeltaFiles(files, openedFilesData);
             setFiles(Array.from(mergedFiles.values()));
           }
         } else {
           // Too many changes - merge files and let full rebuild happen naturally
           const mergedFiles = mergeDeltaFiles(files, openedFilesData);
           setFiles(Array.from(mergedFiles.values()));
           // Tree will rebuild in useMemo below
         }
       }, [openedFilesData, setFiles]);
       ```

    2. Update tree building useMemo to track previous tree:
       ```typescript
       // Build tree structure from flat file list
       const tree = useMemo(() => {
         if (!rootPath || files.length === 0) {
           prevTreeRef.current = [];
           prevFilesRef.current = new Map();
           return [];
         }

         // Check if we can use incremental update
         const currentFiles = new Map(files.map(f => [f.depotPath, f]));
         const changeMap = createChangeMap(prevFilesRef.current, files);

         let newTree: FileTreeNode[];

         if (
           prevTreeRef.current.length > 0 &&
           shouldUseIncrementalUpdate(prevFilesRef.current.size, changeMap.size)
         ) {
           // Incremental update preserving object identity
           newTree = incrementalTreeUpdate(prevTreeRef.current, changeMap);
         } else {
           // Full rebuild
           newTree = buildFileTree(files, rootPath);
         }

         // Update refs for next comparison
         prevTreeRef.current = newTree;
         prevFilesRef.current = currentFiles;

         return newTree;
       }, [files, rootPath]);
       ```

    3. Ensure streaming batch updates also update the refs:
       - In the streaming callback where setFiles is called:
         ```typescript
         // After setFiles in data batch handler:
         prevFilesRef.current = new Map(accumulatedFilesRef.current.map(f => [f.depotPath, f]));
         ```
  </action>
  <verify>
    TypeScript compiles: npm run build
    grep "incrementalTreeUpdate\|shouldUseIncrementalUpdate\|createChangeMap" src/components/FileTree/useFileTree.ts
    grep "prevTreeRef\|prevFilesRef" src/components/FileTree/useFileTree.ts
  </verify>
  <done>
    Delta refresh results trigger incremental merge when <10% files changed
    Full rebuild triggered when >10% files changed or no previous data
    prevTreeRef and prevFilesRef track previous state for comparison
    Streaming updates correctly update refs for subsequent incremental updates
  </done>
</task>

<task type="auto">
  <name>Task 3: Handle focus return and interval timing</name>
  <files>
    src/components/FileTree/useFileTree.ts
  </files>
  <action>
    Add logic for immediate refresh on focus return if interval elapsed.

    1. Track when refresh last occurred:
       ```typescript
       const lastDeltaRefreshRef = useRef<number>(Date.now());
       const lastFullRefreshRef = useRef<number>(Date.now());
       ```

    2. Update timestamps when queries complete:
       - In delta query's onSuccess or after data arrives:
         ```typescript
         // After successful delta refresh
         lastDeltaRefreshRef.current = Date.now();
         ```
       - After streaming completes:
         ```typescript
         // After successful full refresh
         lastFullRefreshRef.current = Date.now();
         ```

    3. Add effect to check for missed refresh on focus return:
       ```typescript
       // Immediate refresh on focus return if interval elapsed while unfocused
       useEffect(() => {
         if (!isWindowFocused) return;
         if (!isConnected || isStreaming) return;

         const now = Date.now();

         // Check if delta interval elapsed
         if (deltaInterval > 0 && now - lastDeltaRefreshRef.current > deltaInterval) {
           queryClient.invalidateQueries({
             queryKey: ['p4', 'fstat', 'opened', p4port, p4user, p4client],
           });
         }

         // Check if full interval elapsed
         if (fullInterval > 0 && now - lastFullRefreshRef.current > fullInterval) {
           queryClient.invalidateQueries({
             queryKey: ['fileTree', rootPath, depotPath],
           });
         }
       }, [
         isWindowFocused,
         isConnected,
         isStreaming,
         deltaInterval,
         fullInterval,
         p4port,
         p4user,
         p4client,
         rootPath,
         depotPath,
         queryClient,
       ]);
       ```

    CONTEXT.md decision: "On focus return: refresh immediately if interval elapsed while unfocused, otherwise wait for normal interval"
  </action>
  <verify>
    TypeScript compiles: npm run build
    grep "lastDeltaRefreshRef\|lastFullRefreshRef" src/components/FileTree/useFileTree.ts
    grep "isWindowFocused.*isConnected" src/components/FileTree/useFileTree.ts
  </verify>
  <done>
    Last refresh timestamps tracked for both delta and full refresh
    Focus return triggers immediate refresh if interval elapsed while blurred
    Normal interval resumes if refresh not yet due
  </done>
</task>

</tasks>

<verification>
npm run build (TypeScript compiles without errors)
npm run dev (app starts, connect to workspace)

Manual verification:
1. Connect to workspace with files
2. Open a file for edit
3. Wait 30s - observe delta refresh queries opened files (check Output window)
4. Wait 5 minutes - observe full refresh (or change fullInterval to shorter for testing)
5. Minimize window, wait, restore - observe immediate refresh if interval elapsed
6. Verify tree doesn't flicker during refresh (scroll position preserved)
</verification>

<success_criteria>
- Delta refresh (30s default) queries only opened files
- Full refresh (5min default) uses streaming fstat for all workspace files
- Auto-refresh pauses when window loses focus
- On focus return, immediate refresh if interval elapsed, else normal wait
- Incremental tree update when <10% files change (no full rebuild)
- Tree scroll position preserved during refresh (no flicker)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/24-tree-performance-delta-refresh/24-04-SUMMARY.md`
</output>
