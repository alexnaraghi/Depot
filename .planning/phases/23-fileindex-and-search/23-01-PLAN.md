---
phase: 23-fileindex-and-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/file_index/mod.rs
  - src-tauri/src/file_index/search.rs
  - src-tauri/src/commands/search.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "FileIndex accepts file batches and stores depot paths with modification timestamps"
    - "Search query returns fuzzy matches with combined fuzzy+recency scores in <5ms"
    - "Search supports both fuzzy and exact matching modes"
    - "Tauri commands search_workspace_files and add_files_to_index exist and work"
  artifacts:
    - path: "src-tauri/src/file_index/mod.rs"
      provides: "FileIndex struct with add_batch, clear, file count"
      exports: ["FileIndex", "FileIndexState"]
    - path: "src-tauri/src/file_index/search.rs"
      provides: "Search implementation with fuzzy+recency scoring"
      exports: ["SearchResult", "SearchMode", "search_with_mode"]
    - path: "src-tauri/src/commands/search.rs"
      provides: "Tauri commands for search and index management"
      exports: ["search_workspace_files", "add_files_to_index", "clear_file_index", "get_file_index_count"]
  key_links:
    - from: "src-tauri/src/commands/search.rs"
      to: "FileIndexState"
      via: "tauri::State injection"
      pattern: "State<'_, FileIndexState>"
    - from: "src-tauri/src/lib.rs"
      to: "FileIndexState"
      via: ".manage() registration"
      pattern: "\\.manage\\(FileIndexState"
---

<objective>
Create the Rust-side FileIndex module with nucleo fuzzy matching that provides instant workspace file search.

Purpose: This is the foundation for Phase 23's search feature. A persistent in-memory index using nucleo enables <5ms search across 100K files, replacing the per-keystroke client-side fuzzy matching that doesn't scale.

Output: FileIndex module with search commands ready for frontend integration.
</objective>

<execution_context>
@C:\Users\a\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\a\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-fileindex-and-search/23-RESEARCH.md

# Existing Rust patterns
@src-tauri/src/lib.rs
@src-tauri/src/state/mod.rs
@src-tauri/src/commands/mod.rs
@src-tauri/src/commands/p4/types.rs
@src-tauri/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add nucleo dependency and create FileIndex module</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/file_index/mod.rs
    src-tauri/src/file_index/search.rs
  </files>
  <action>
1. Add nucleo to Cargo.toml:
   ```toml
   nucleo-matcher = "0.3"
   ```
   Note: Use nucleo-matcher (the low-level matcher crate), not the high-level nucleo crate. Version 0.3 is stable.

2. Create src-tauri/src/file_index/mod.rs:
   ```rust
   pub mod search;

   use std::sync::Arc;
   use tokio::sync::Mutex;
   pub use search::{SearchResult, SearchMode};

   /// Entry in the file index: depot path + modification timestamp (unix seconds)
   #[derive(Clone)]
   pub struct FileEntry {
       pub depot_path: String,
       pub mod_time: u64,
   }

   /// Persistent file index for workspace search
   pub struct FileIndex {
       files: Vec<FileEntry>,
   }

   impl FileIndex {
       pub fn new() -> Self {
           Self { files: Vec::new() }
       }

       /// Add a batch of files to the index
       pub fn add_batch(&mut self, entries: Vec<FileEntry>) {
           self.files.extend(entries);
       }

       /// Clear all entries (before workspace reload)
       pub fn clear(&mut self) {
           self.files.clear();
       }

       /// Get current file count
       pub fn len(&self) -> usize {
           self.files.len()
       }

       pub fn is_empty(&self) -> bool {
           self.files.is_empty()
       }

       /// Get reference to files for searching
       pub fn files(&self) -> &[FileEntry] {
           &self.files
       }
   }

   impl Default for FileIndex {
       fn default() -> Self {
           Self::new()
       }
   }

   /// Thread-safe state wrapper for Tauri
   pub type FileIndexState = Arc<Mutex<FileIndex>>;

   pub fn create_file_index_state() -> FileIndexState {
       Arc::new(Mutex::new(FileIndex::new()))
   }
   ```

3. Create src-tauri/src/file_index/search.rs:
   ```rust
   use super::{FileIndex, FileEntry};
   use nucleo_matcher::{Matcher, Config};
   use nucleo_matcher::pattern::{Pattern, CaseMatching, Normalization, AtomKind};
   use serde::Serialize;

   #[derive(Clone, Copy, Debug, PartialEq)]
   pub enum SearchMode {
       Fuzzy,
       Exact,
   }

   #[derive(Clone, Serialize)]
   #[serde(rename_all = "camelCase")]
   pub struct SearchResult {
       pub depot_path: String,
       pub score: u32,
       pub mod_time: u64,
   }

   impl FileIndex {
       /// Search with combined fuzzy score and recency bias
       pub fn search(&self, query: &str, mode: SearchMode, max_results: usize) -> Vec<SearchResult> {
           if query.is_empty() {
               return Vec::new();
           }

           let mut matcher = Matcher::new(Config::DEFAULT);
           let mut haystack_buf = Vec::new();

           // Create pattern based on mode
           let pattern = match mode {
               SearchMode::Fuzzy => Pattern::parse(query, CaseMatching::Ignore, Normalization::Smart),
               SearchMode::Exact => Pattern::new(
                   query,
                   CaseMatching::Ignore,
                   Normalization::Smart,
                   AtomKind::Substring,
               ),
           };

           // Current time for recency calculation
           let now = std::time::SystemTime::now()
               .duration_since(std::time::UNIX_EPOCH)
               .map(|d| d.as_secs())
               .unwrap_or(0);

           let mut results: Vec<SearchResult> = Vec::new();

           for entry in &self.files {
               // Convert path to Utf32Str for nucleo
               haystack_buf.clear();
               let haystack = nucleo_matcher::Utf32Str::new(&entry.depot_path, &mut haystack_buf);

               if let Some(fuzzy_score) = pattern.score(haystack, &mut matcher) {
                   // Apply recency bias: files modified in last 7 days get 1.5x boost
                   let age_days = if entry.mod_time > 0 && now > entry.mod_time {
                       (now - entry.mod_time) / 86400
                   } else {
                       u64::MAX // Unknown mod time, no boost
                   };

                   let recency_multiplier = if age_days < 7 { 1.5 } else { 1.0 };
                   let combined_score = (fuzzy_score as f64 * recency_multiplier) as u32;

                   results.push(SearchResult {
                       depot_path: entry.depot_path.clone(),
                       score: combined_score,
                       mod_time: entry.mod_time,
                   });
               }
           }

           // Sort by score descending, then path ascending for stable ordering
           results.sort_by(|a, b| {
               b.score.cmp(&a.score)
                   .then_with(|| a.depot_path.cmp(&b.depot_path))
           });

           results.truncate(max_results);
           results
       }
   }
   ```
  </action>
  <verify>
    Run `cd C:\Projects\Fun\p4now\src-tauri && cargo check` - should compile without errors.
    Verify file_index module exports FileIndex, FileIndexState, SearchResult, SearchMode.
  </verify>
  <done>
    FileIndex struct exists with add_batch, clear, len methods.
    Search implementation uses nucleo for fuzzy matching with recency bias.
    Code compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Tauri search commands</name>
  <files>
    src-tauri/src/commands/search.rs
    src-tauri/src/commands/mod.rs
  </files>
  <action>
1. Create src-tauri/src/commands/search.rs:
   ```rust
   use tauri::State;
   use crate::file_index::{FileIndexState, FileEntry, SearchResult, SearchMode};

   /// Search workspace files using the persistent index
   #[tauri::command]
   pub async fn search_workspace_files(
       query: String,
       mode: String,
       max_results: usize,
       state: State<'_, FileIndexState>,
   ) -> Result<Vec<SearchResult>, String> {
       let index = state.lock().await;

       let search_mode = match mode.as_str() {
           "exact" => SearchMode::Exact,
           _ => SearchMode::Fuzzy,
       };

       Ok(index.search(&query, search_mode, max_results))
   }

   /// Add files to the index (called from streaming fstat)
   #[tauri::command]
   pub async fn add_files_to_index(
       files: Vec<FileIndexEntry>,
       state: State<'_, FileIndexState>,
   ) -> Result<usize, String> {
       let mut index = state.lock().await;

       let entries: Vec<FileEntry> = files
           .into_iter()
           .map(|f| FileEntry {
               depot_path: f.depot_path,
               mod_time: f.mod_time,
           })
           .collect();

       let count = entries.len();
       index.add_batch(entries);

       Ok(index.len())
   }

   /// Clear the file index (called when workspace changes)
   #[tauri::command]
   pub async fn clear_file_index(
       state: State<'_, FileIndexState>,
   ) -> Result<(), String> {
       let mut index = state.lock().await;
       index.clear();
       Ok(())
   }

   /// Get current index size
   #[tauri::command]
   pub async fn get_file_index_count(
       state: State<'_, FileIndexState>,
   ) -> Result<usize, String> {
       let index = state.lock().await;
       Ok(index.len())
   }

   /// Input type for add_files_to_index command
   #[derive(serde::Deserialize)]
   #[serde(rename_all = "camelCase")]
   pub struct FileIndexEntry {
       pub depot_path: String,
       pub mod_time: u64,
   }
   ```

2. Update src-tauri/src/commands/mod.rs to export search commands:
   Add at the top with other mod declarations:
   ```rust
   mod search;
   ```

   Add in the pub use block:
   ```rust
   pub use search::{search_workspace_files, add_files_to_index, clear_file_index, get_file_index_count};
   ```
  </action>
  <verify>
    Run `cd C:\Projects\Fun\p4now\src-tauri && cargo check` - should compile without errors.
    Verify commands are exported from commands module.
  </verify>
  <done>
    Four Tauri commands exist: search_workspace_files, add_files_to_index, clear_file_index, get_file_index_count.
    Commands properly use FileIndexState via dependency injection.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register FileIndexState and commands in Tauri app</name>
  <files>
    src-tauri/src/lib.rs
  </files>
  <action>
1. Update src-tauri/src/lib.rs:

   Add file_index module declaration after state:
   ```rust
   mod file_index;
   ```

   Import the state creator:
   ```rust
   use file_index::create_file_index_state;
   ```

   In the tauri::Builder chain, add .manage() for FileIndexState BEFORE ProcessManager:
   ```rust
   .manage(create_file_index_state())
   .manage(ProcessManager::new())
   ```

   Add the search commands to invoke_handler (add after p4_annotate):
   ```rust
   commands::search_workspace_files,
   commands::add_files_to_index,
   commands::clear_file_index,
   commands::get_file_index_count,
   ```

2. Verify the full lib.rs compiles and the app starts.
  </action>
  <verify>
    Run `cd C:\Projects\Fun\p4now\src-tauri && cargo check` - should compile without errors.
    Run `cd C:\Projects\Fun\p4now && npm run tauri dev` briefly to verify app starts (Ctrl+C to exit).
  </verify>
  <done>
    FileIndexState is registered in Tauri app state.
    All four search commands are registered in invoke_handler.
    App compiles and starts successfully.
  </done>
</task>

</tasks>

<verification>
1. Cargo check passes with no errors
2. App starts successfully with `npm run tauri dev`
3. FileIndex module exists with expected structure
4. Search commands are registered and callable (frontend integration in Plan 02)
</verification>

<success_criteria>
- nucleo-matcher added to Cargo.toml dependencies
- FileIndex struct with add_batch, clear, len, search methods
- SearchResult and SearchMode types defined
- Four Tauri commands registered: search_workspace_files, add_files_to_index, clear_file_index, get_file_index_count
- App compiles and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/23-fileindex-and-search/23-01-SUMMARY.md`
</output>
