---
phase: 23-fileindex-and-search
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - src/hooks/useFileSearch.ts
  - src/stores/searchFilterStore.ts
  - src/components/FileTree/FileTree.tsx
  - src/components/SearchBar.tsx
autonomous: true

must_haves:
  truths:
    - "File tree filter queries Rust backend instead of computing matches client-side"
    - "Search results update within 150ms of typing (debounce + instant backend)"
    - "User can toggle between fuzzy and exact matching modes"
    - "Result count displays near the filter input"
    - "Tree stays hierarchical during filter with ancestor paths visible"
  artifacts:
    - path: "src/hooks/useFileSearch.ts"
      provides: "React hook for backend search queries"
      exports: ["useFileSearch"]
    - path: "src/stores/searchFilterStore.ts"
      provides: "Search mode state (fuzzy/exact)"
      contains: "searchMode"
    - path: "src/components/FileTree/FileTree.tsx"
      provides: "Updated filter to use Rust index"
      contains: "useFileSearch"
  key_links:
    - from: "src/hooks/useFileSearch.ts"
      to: "search_workspace_files"
      via: "Tauri invoke"
      pattern: "invoke.*search_workspace_files"
    - from: "src/components/FileTree/FileTree.tsx"
      to: "useFileSearch"
      via: "hook import"
      pattern: "import.*useFileSearch"
---

<objective>
Integrate the Rust-side FileIndex with the frontend file tree filter for instant search at scale.

Purpose: Replace client-side microfuzz matching with backend nucleo queries, enabling instant search across 100K+ files while preserving the hierarchical tree presentation.

Output: File tree filter uses persistent Rust index, supports fuzzy/exact toggle, displays match count.
</objective>

<execution_context>
@C:\Users\a\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\a\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-fileindex-and-search/23-RESEARCH.md
@.planning/phases/23-fileindex-and-search/23-01-SUMMARY.md

# Existing frontend patterns
@src/components/FileTree/FileTree.tsx
@src/stores/searchFilterStore.ts
@src/hooks/useDebounce.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useFileSearch hook and update searchFilterStore</name>
  <files>
    src/hooks/useFileSearch.ts
    src/stores/searchFilterStore.ts
  </files>
  <action>
1. Create src/hooks/useFileSearch.ts:
   ```typescript
   import { useQuery } from '@tanstack/react-query';
   import { invoke } from '@tauri-apps/api/core';
   import { useSearchFilterStore } from '@/stores/searchFilterStore';
   import { useDebounce } from './useDebounce';

   export interface SearchResult {
     depotPath: string;
     score: number;
     modTime: number;
   }

   /**
    * Hook for searching workspace files via Rust backend
    *
    * Uses the persistent FileIndex for instant fuzzy search across large workspaces.
    * Debounces queries by 150ms to prevent excessive backend calls during typing.
    */
   export function useFileSearch(query: string) {
     const searchMode = useSearchFilterStore(s => s.searchMode);
     const debouncedQuery = useDebounce(query, 150);

     return useQuery({
       queryKey: ['file-search', debouncedQuery, searchMode],
       queryFn: async (): Promise<SearchResult[]> => {
         if (!debouncedQuery.trim()) {
           return [];
         }

         const results = await invoke<SearchResult[]>('search_workspace_files', {
           query: debouncedQuery,
           mode: searchMode,
           maxResults: 500, // Get more results for hierarchical filtering
         });

         return results;
       },
       enabled: debouncedQuery.length > 0,
       staleTime: 5000, // Cache results for 5s
       gcTime: 30000,   // Keep in cache for 30s
     });
   }

   /**
    * Hook for adding files to the index (called from streaming fstat)
    */
   export async function addFilesToIndex(files: Array<{ depotPath: string; modTime: number }>) {
     await invoke('add_files_to_index', { files });
   }

   /**
    * Hook for clearing the index (called on workspace change)
    */
   export async function clearFileIndex() {
     await invoke('clear_file_index');
   }

   /**
    * Get current index count
    */
   export async function getFileIndexCount(): Promise<number> {
     return await invoke<number>('get_file_index_count');
   }
   ```

2. Update src/stores/searchFilterStore.ts to add search mode:
   Add to interface:
   ```typescript
   searchMode: 'fuzzy' | 'exact';
   toggleSearchMode: () => void;
   ```

   Add to initial state:
   ```typescript
   searchMode: 'fuzzy',
   ```

   Add action:
   ```typescript
   toggleSearchMode: () => set((state) => ({
     searchMode: state.searchMode === 'fuzzy' ? 'exact' : 'fuzzy',
   })),
   ```

   Also update clearFilter to NOT reset searchMode (preserve user preference):
   ```typescript
   clearFilter: () => {
     set({
       filterTerm: '',
       isActive: false,
       fileTreeMatchCount: 0,
       changelistMatchCount: 0,
       // Note: searchMode intentionally NOT reset - preserve user preference
     });
     useDetailPaneStore.getState().clear();
   },
   ```
  </action>
  <verify>
    Run `npm run typecheck` - should pass with no errors.
    Verify useFileSearch hook exports correctly.
    Verify searchFilterStore has searchMode and toggleSearchMode.
  </verify>
  <done>
    useFileSearch hook exists and invokes search_workspace_files command.
    searchFilterStore has searchMode state and toggle action.
    TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update FileTree to use Rust index for filtering</name>
  <files>
    src/components/FileTree/FileTree.tsx
  </files>
  <action>
Update FileTree.tsx to use backend search instead of client-side microfuzz:

1. Remove microfuzz import:
   ```typescript
   // REMOVE: import createFuzzySearch from '@nozbe/microfuzz';
   ```

2. Add useFileSearch import:
   ```typescript
   import { useFileSearch } from '@/hooks/useFileSearch';
   ```

3. Replace the filterResults useCallback with a simpler version that uses backend results:
   ```typescript
   // Apply filtering based on backend search results
   const applyFilter = useCallback((data: FileNodeData[], matchPaths: Set<string>): FileNodeData[] => {
     if (matchPaths.size === 0) {
       // No filter active - return all nodes without dimming
       return data;
     }

     return data.map(node => {
       if (node.isFolder) {
         // Folder: recursively process children
         const filteredChildren = node.children ? applyFilter(node.children, matchPaths) : undefined;
         // Folder is dimmed if ALL its children are dimmed
         const allChildrenDimmed = filteredChildren && filteredChildren.length > 0
           && filteredChildren.every(child => child.dimmed);
         return {
           ...node,
           children: filteredChildren,
           dimmed: allChildrenDimmed,
         };
       } else {
         // File: check if depot path is in match set
         const depotPath = node.file?.depotPath;
         const matches = depotPath && matchPaths.has(depotPath);
         return {
           ...node,
           dimmed: !matches,
         };
       }
     });
   }, []);
   ```

4. Use useFileSearch hook and build match set:
   ```typescript
   // Backend search query
   const { data: searchResults, isLoading: isSearching } = useFileSearch(filterTerm);

   // Build set of matching depot paths from backend results
   const matchPaths = useMemo(() => {
     if (!searchResults || searchResults.length === 0 || !debouncedFilterTerm.trim()) {
       return new Set<string>();
     }
     return new Set(searchResults.map(r => r.depotPath));
   }, [searchResults, debouncedFilterTerm]);

   // Apply filter to tree
   const filteredTree = useMemo(() => {
     if (!debouncedFilterTerm.trim()) {
       return tree;
     }
     return applyFilter(tree, matchPaths);
   }, [tree, matchPaths, debouncedFilterTerm, applyFilter]);

   // Report match count
   useEffect(() => {
     setFileTreeMatchCount(matchPaths.size);
   }, [matchPaths.size, setFileTreeMatchCount]);
   ```

5. Remove the old filterResults call and matchCount destructuring:
   ```typescript
   // REMOVE: const { tree: filteredTree, matchCount } = filterResults(tree, debouncedFilterTerm);
   // REMOVE: useEffect for matchCount
   ```

6. Update the Tree component to use filteredTree:
   - This should already be the case from existing code

7. Add useMemo import if not present:
   ```typescript
   import { useState, useCallback, useRef, useEffect, useMemo } from 'react';
   ```

8. Keep the useDebounce for UI responsiveness but note the hook also debounces internally.
   The debouncedFilterTerm is still useful for the UI state (isActive indicator).
  </action>
  <verify>
    Run `npm run typecheck` - should pass.
    Run `npm run tauri dev` and test:
    1. Type in filter input - results should appear within ~200ms
    2. Matching files should be visible, non-matching should be dimmed
    3. Folder hierarchy should be preserved (matching files show with their ancestor folders)
    4. Clear filter - all files visible again
  </verify>
  <done>
    FileTree uses useFileSearch hook for backend queries.
    Filtering preserves hierarchical tree structure.
    Match count updates from backend results.
    microfuzz import removed (no longer used for file tree).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add search mode toggle and result count to SearchBar</name>
  <files>
    src/components/SearchBar.tsx
  </files>
  <action>
Update SearchBar.tsx to display result count and search mode toggle:

1. Add imports:
   ```typescript
   import { useSearchFilterStore } from '@/stores/searchFilterStore';
   ```

2. Get search mode state:
   ```typescript
   const searchMode = useSearchFilterStore(s => s.searchMode);
   const toggleSearchMode = useSearchFilterStore(s => s.toggleSearchMode);
   const fileTreeMatchCount = useSearchFilterStore(s => s.fileTreeMatchCount);
   const changelistMatchCount = useSearchFilterStore(s => s.changelistMatchCount);
   const isActive = useSearchFilterStore(s => s.isActive);
   ```

3. Add total match count display near the input:
   ```typescript
   const totalMatchCount = fileTreeMatchCount + changelistMatchCount;
   ```

4. Add a search mode toggle button. Place it next to the search input or in the filter area.
   Use a small toggle button that shows current mode:
   ```tsx
   {/* Search mode toggle */}
   {isActive && (
     <button
       onClick={toggleSearchMode}
       className="px-2 py-1 text-xs rounded border border-border hover:bg-accent/50 transition-colors"
       title={`Search mode: ${searchMode}. Click to toggle.`}
     >
       {searchMode === 'fuzzy' ? 'Fuzzy' : 'Exact'}
     </button>
   )}
   ```

5. Add match count display when filter is active:
   ```tsx
   {isActive && totalMatchCount > 0 && (
     <span className="text-xs text-muted-foreground">
       {totalMatchCount} match{totalMatchCount !== 1 ? 'es' : ''}
     </span>
   )}
   ```

6. If there's no existing SearchBar.tsx structure to modify, integrate these elements
   into the existing filter input area. The exact placement is at Claude's discretion
   per the CONTEXT.md, but should be near the filter input for discoverability.

7. Add keyboard shortcut for mode toggle (Ctrl+E or similar):
   ```typescript
   useEffect(() => {
     const handleKeyDown = (e: KeyboardEvent) => {
       if (e.ctrlKey && e.key === 'e' && isActive) {
         e.preventDefault();
         toggleSearchMode();
       }
     };
     window.addEventListener('keydown', handleKeyDown);
     return () => window.removeEventListener('keydown', handleKeyDown);
   }, [isActive, toggleSearchMode]);
   ```
  </action>
  <verify>
    Run `npm run typecheck` - should pass.
    Run `npm run tauri dev` and test:
    1. Type in filter - match count should appear (e.g., "15 matches")
    2. Click mode toggle - should switch between "Fuzzy" and "Exact"
    3. Mode change should affect search results (exact is more restrictive)
    4. Ctrl+E should toggle mode when filter is active
  </verify>
  <done>
    SearchBar displays match count when filter is active.
    Search mode toggle button visible and functional.
    Keyboard shortcut (Ctrl+E) toggles search mode.
    Mode preference preserved across filter clears.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors (`npm run typecheck`)
2. App runs and filter works with backend search
3. Hierarchical tree preserved during filtering (folders visible with matching descendants)
4. Match count displays correctly
5. Fuzzy/exact toggle works and affects results
6. Search feels instant (<200ms response with 150ms debounce)
</verification>

<success_criteria>
- useFileSearch hook calls search_workspace_files Tauri command
- FileTree.tsx uses backend search results instead of microfuzz
- Tree stays hierarchical during filter (matching files + ancestor folders visible)
- Match count displays near filter input
- Search mode toggle (Fuzzy/Exact) is visible and functional
- Ctrl+E keyboard shortcut toggles search mode
- Filter response feels instant (debounce + fast backend = <200ms perceived latency)
</success_criteria>

<output>
After completion, create `.planning/phases/23-fileindex-and-search/23-02-SUMMARY.md`
</output>
