---
phase: 21-async-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/state/process_manager.rs
  - src-tauri/src/commands/process.rs
autonomous: true

must_haves:
  truths:
    - "ProcessManager stores tokio::process::Child handles instead of std::process::Child"
    - "ProcessManager.kill() calls .wait().await after .kill().await to prevent zombie processes"
    - "ProcessManager.kill_all() calls .wait().await after .kill().await for every child"
    - "spawn_p4_command uses tokio::process::Command and tokio::spawn (not std::thread::spawn)"
    - "p4_command uses tokio::process::Command with .output().await (not blocking .output())"
    - "tokio features process and io-util are enabled in Cargo.toml"
  artifacts:
    - path: "src-tauri/Cargo.toml"
      provides: "tokio feature flags for async process management"
      contains: 'features = ["sync", "process", "io-util"]'
    - path: "src-tauri/src/state/process_manager.rs"
      provides: "Async ProcessManager with tokio::process::Child"
      contains: "tokio::process::Child"
    - path: "src-tauri/src/commands/process.rs"
      provides: "Async spawn_p4_command and p4_command using tokio::process"
      contains: "tokio::process::Command"
  key_links:
    - from: "src-tauri/src/commands/process.rs"
      to: "src-tauri/src/state/process_manager.rs"
      via: "state.register(child) with tokio::process::Child"
      pattern: "state\\.register\\(child\\)"
---

<objective>
Migrate ProcessManager and streaming commands from std::process to tokio::process for non-blocking async execution.

Purpose: This is the foundation for all v5.0 streaming work. Currently, every p4 command blocks a tokio worker thread because it uses std::process. Migrating to tokio::process unblocks the async runtime, enabling concurrent p4 operations and process cancellation without thread starvation.

Output: ProcessManager accepts tokio::process::Child, process.rs commands use tokio::process::Command, zombie processes are prevented via .wait().await.
</objective>

<execution_context>
@C:\Users\a\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\a\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src-tauri/Cargo.toml
@src-tauri/src/state/process_manager.rs
@src-tauri/src/commands/process.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable tokio features and migrate ProcessManager to async</name>
  <files>src-tauri/Cargo.toml, src-tauri/src/state/process_manager.rs</files>
  <action>
1. In Cargo.toml, update the tokio dependency to add process and io-util features:
   `tokio = { version = "1", features = ["sync", "process", "io-util"] }`

2. In process_manager.rs, migrate from std::process::Child to tokio::process::Child:
   - Replace `use std::process::Child;` with `use tokio::process::Child;`
   - The HashMap type stays the same: `HashMap<String, Child>` but now uses tokio's Child
   - In `register()`: No signature change needed (accepts Child, which is now tokio's Child)
   - In `kill()`:
     - Change taskkill to use `tokio::process::Command` instead of `std::process::Command`:
       ```rust
       let _ = tokio::process::Command::new("taskkill")
           .args(["/F", "/T", "/PID", &pid.to_string()])
           .output()
           .await;
       ```
     - Note: `child.id()` on tokio::process::Child returns `Option<u32>` not `u32`, so wrap in `if let Some(pid) = child.id()`
     - Change `child.kill().map_err(...)` to `child.kill().await.map_err(...)`
     - CRITICAL: Add `.wait().await` after kill to reap zombie process:
       ```rust
       child.kill().await.map_err(|e| e.to_string())?;
       let _ = child.wait().await; // Reap zombie
       ```
   - In `kill_all()`:
     - Same changes as kill(): use tokio::process::Command for taskkill, child.id() returns Option, .kill().await, add .wait().await
     - Note: Since kill_all iterates via drain(), you need to handle async operations. Use:
       ```rust
       for (_, mut child) in processes.drain() {
           #[cfg(target_os = "windows")]
           {
               if let Some(pid) = child.id() {
                   let _ = tokio::process::Command::new("taskkill")
                       .args(["/F", "/T", "/PID", &pid.to_string()])
                       .output()
                       .await;
               }
           }
           let _ = child.kill().await;
           let _ = child.wait().await;
       }
       ```
  </action>
  <verify>
Run `cargo check` from src-tauri directory. It should compile (process.rs will have warnings about std::process::Command usage, which is expected — those get fixed in the next task).

Verify: `grep -n "tokio::process" src-tauri/src/state/process_manager.rs` shows Child import and Command usage.
Verify: `grep "process.*io-util" src-tauri/Cargo.toml` shows features enabled.
  </verify>
  <done>
ProcessManager uses tokio::process::Child, kills use .await, and .wait().await prevents zombies. Cargo.toml has process + io-util features.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate process.rs commands to tokio::process</name>
  <files>src-tauri/src/commands/process.rs</files>
  <action>
Migrate all commands in process.rs from std::process to tokio::process:

1. Replace imports at top of file:
   - Remove: `use std::io::{BufRead, BufReader};` and `use std::process::{Command, Stdio};`
   - Add: `use tokio::process::Command;` and `use std::process::Stdio;` and `use tokio::io::{AsyncBufReadExt, BufReader};`

2. In `spawn_p4_command`:
   - Change `Command::new("p4")` — this is now tokio::process::Command (from the import change)
   - Change `.spawn()` — tokio's Command.spawn() returns tokio::process::Child
   - Change stdout/stderr reading from `std::thread::spawn` to `tokio::spawn` with async:
     ```rust
     if let Some(stdout) = stdout {
         tokio::spawn(async move {
             let mut lines = BufReader::new(stdout).lines();
             while let Ok(Some(line)) = lines.next_line().await {
                 let _ = on_output_clone.send(OutputLine {
                     line,
                     is_stderr: false,
                 });
             }
         });
     }
     ```
   - Same pattern for stderr reading

3. In `p4_command`:
   - Change `Command::new("p4")` — now tokio::process::Command
   - Change `.output()` to `.output().await` — this is the key change that makes it non-blocking
   - The rest (status check, stdout parsing) stays the same

4. `kill_process` and `kill_all_processes` — no changes needed (they just call ProcessManager methods).
  </action>
  <verify>
Run `cargo check` from src-tauri directory. The process.rs commands should compile cleanly. There will still be warnings/errors in p4handlers.rs (those are migrated in Plan 02).

Verify: `grep -c "std::thread::spawn" src-tauri/src/commands/process.rs` returns 0 (no more blocking threads).
Verify: `grep -c "tokio::spawn" src-tauri/src/commands/process.rs` returns 2 (stdout + stderr readers).
  </verify>
  <done>
spawn_p4_command uses tokio::process::Command with tokio::spawn for streaming. p4_command uses async .output().await. No blocking threads remain in process.rs.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes from src-tauri directory (may have p4handlers.rs errors — those are Plan 02 scope)
2. ProcessManager uses `tokio::process::Child` (not `std::process::Child`)
3. `.wait().await` called after every `.kill().await` in ProcessManager
4. process.rs uses `tokio::process::Command` and `tokio::spawn` (not std::thread::spawn)
5. No `use std::process::Child` remains in process_manager.rs
6. No `std::thread::spawn` remains in process.rs
</verification>

<success_criteria>
ProcessManager tracks tokio::process::Child handles with proper zombie prevention. Streaming commands (spawn_p4_command) use tokio::spawn instead of std::thread::spawn. The basic p4_command uses non-blocking .output().await. tokio features process and io-util are enabled.
</success_criteria>

<output>
After completion, create `.planning/phases/21-async-foundation/21-01-SUMMARY.md`
</output>
