---
phase: 21-async-foundation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useDebounce.ts
  - src/components/FileTree/FileTree.tsx
autonomous: true

must_haves:
  truths:
    - "useDebounce hook delays value updates by specified milliseconds (default 150ms)"
    - "useDebounce cleans up timeout on unmount (no memory leak)"
    - "FileTree uses useDebounce(filterTerm, 150) instead of useDeferredValue(filterTerm)"
    - "Filter input feels responsive (150ms delay is imperceptible for typing)"
  artifacts:
    - path: "src/hooks/useDebounce.ts"
      provides: "Generic useDebounce hook"
      exports: ["useDebounce"]
      min_lines: 15
    - path: "src/components/FileTree/FileTree.tsx"
      provides: "FileTree with debounced filter"
      contains: "useDebounce"
  key_links:
    - from: "src/components/FileTree/FileTree.tsx"
      to: "src/hooks/useDebounce.ts"
      via: "import { useDebounce } from"
      pattern: "useDebounce.*filterTerm.*150"
---

<objective>
Create a useDebounce hook and integrate it into FileTree to prevent redundant filter computation on rapid keystrokes.

Purpose: The current FileTree uses React's useDeferredValue which still triggers computation on every keystroke (it just defers rendering). With 10,000+ files, each keystroke triggers a full fuzzy match pass. A true debounce delays the computation until the user pauses typing, reducing filter operations by ~90% during rapid typing.

Output: A reusable useDebounce hook in src/hooks/ and FileTree using debounced filter term.
</objective>

<execution_context>
@C:\Users\a\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\a\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@src/hooks/
@src/components/FileTree/FileTree.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useDebounce hook</name>
  <files>src/hooks/useDebounce.ts</files>
  <action>
Create `src/hooks/useDebounce.ts` with a generic debounce hook:

```typescript
import { useState, useEffect } from 'react';

/**
 * Delays updating a value until the input stabilizes for the specified delay.
 * Useful for search/filter inputs to prevent redundant computation.
 *
 * @param value - The value to debounce
 * @param delay - Delay in milliseconds (default: 150ms)
 * @returns The debounced value
 */
export function useDebounce<T>(value: T, delay: number = 150): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
```

This is a standard React pattern. The cleanup function in useEffect ensures:
- Timer is cleared if value changes before delay expires (debounce behavior)
- Timer is cleared on component unmount (no memory leak)
  </action>
  <verify>
Verify file exists: `ls src/hooks/useDebounce.ts`
Verify exports: `grep "export function useDebounce" src/hooks/useDebounce.ts`
  </verify>
  <done>
useDebounce hook exists at src/hooks/useDebounce.ts, exports a generic function with 150ms default delay, handles cleanup on unmount.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate useDebounce into FileTree</name>
  <files>src/components/FileTree/FileTree.tsx</files>
  <action>
Update FileTree.tsx to use useDebounce instead of useDeferredValue:

1. Update imports:
   - Remove `useDeferredValue` from the React import: `import { useState, useCallback, useRef, useEffect } from 'react';`
   - Add: `import { useDebounce } from '../../hooks/useDebounce';`

2. Replace the filter term debouncing:
   - Remove: `const deferredFilterTerm = useDeferredValue(filterTerm);`
   - Add: `const debouncedFilterTerm = useDebounce(filterTerm, 150);`

3. Update all references from `deferredFilterTerm` to `debouncedFilterTerm` throughout the component. Search for every occurrence of `deferredFilterTerm` and replace with `debouncedFilterTerm`. This variable is used in:
   - The useMemo that computes filtered/dimmed nodes
   - Any useEffect that depends on the filter term
   - Possibly the match count calculation

The variable rename from `deferredFilterTerm` to `debouncedFilterTerm` makes the behavior clear in code.
  </action>
  <verify>
Run `npx tsc --noEmit` from the project root to verify TypeScript compilation.

Verify: `grep "useDeferredValue" src/components/FileTree/FileTree.tsx` returns nothing (removed).
Verify: `grep "useDebounce" src/components/FileTree/FileTree.tsx` returns the import and usage.
Verify: `grep "debouncedFilterTerm" src/components/FileTree/FileTree.tsx` shows the variable in use.
  </verify>
  <done>
FileTree uses useDebounce(filterTerm, 150) instead of useDeferredValue. Filter computation is delayed until user pauses typing for 150ms. No useDeferredValue references remain for filterTerm.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (TypeScript compiles cleanly)
2. useDebounce.ts exists with exported generic hook
3. FileTree.tsx imports and uses useDebounce (not useDeferredValue) for filterTerm
4. No `useDeferredValue` import remains in FileTree.tsx for filter purposes
5. Variable name is `debouncedFilterTerm` throughout FileTree.tsx
</verification>

<success_criteria>
A reusable useDebounce hook exists. FileTree filter input is debounced at 150ms, preventing redundant fuzzy matching during rapid typing. TypeScript compiles cleanly.
</success_criteria>

<output>
After completion, create `.planning/phases/21-async-foundation/21-03-SUMMARY.md`
</output>
