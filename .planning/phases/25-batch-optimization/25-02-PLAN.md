---
phase: 25-batch-optimization
plan: 02
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - src/lib/tauri.ts
  - src/components/ChangelistPanel/useChangelists.ts
autonomous: true

must_haves:
  truths:
    - "Shelved files load from single batch call instead of N individual queries"
    - "Progress indicator shows in status bar during batch load"
    - "Partial failures show yellow toast with count summary"
    - "User can cancel batch operation mid-load"
    - "Partial results kept when user cancels"
  artifacts:
    - path: "src/lib/tauri.ts"
      provides: "TypeScript types and invoke wrapper for batch command"
      contains: "ShelvedBatchProgress"
    - path: "src/components/ChangelistPanel/useChangelists.ts"
      provides: "Batch shelved files loading with progress"
      contains: "invokeP4DescribeShelvedBatch"
  key_links:
    - from: "useChangelists.ts"
      to: "tauri.ts:invokeP4DescribeShelvedBatch"
      via: "Channel-based invoke"
      pattern: "invokeP4DescribeShelvedBatch"
    - from: "useChangelists.ts"
      to: "useOperationStore"
      via: "progress tracking"
      pattern: "startOperation|updateProgress"
---

<objective>
Integrate batch shelved file loading into frontend

Purpose: Replace useQueries N+1 pattern with single batch call, show progress in status bar, handle partial failures gracefully with toast notification.

Output: Updated useChangelists.ts using batch command, TypeScript types in tauri.ts
</objective>

<execution_context>
@C:\Users\a\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\a\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-batch-optimization/25-01-SUMMARY.md
@.planning/phases/25-batch-optimization/25-CONTEXT.md (user decisions on error handling, progress format)
@src/lib/tauri.ts (invoke patterns, Channel usage)
@src/components/ChangelistPanel/useChangelists.ts
@src/store/operation.ts (startOperation, updateProgress, completeOperation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TypeScript types and invoke wrapper to tauri.ts</name>
  <files>src/lib/tauri.ts</files>
  <action>
Add TypeScript types matching Rust ShelvedBatchProgress enum:

1. Add types after existing P4ShelvedFile:
```typescript
export interface ShelvedBatchResult {
  changelistId: number;
  files: P4ShelvedFile[] | null;
  error: string | null;
}

export type ShelvedBatchProgress =
  | { type: 'progress'; loaded: number; total: number; message: string }
  | { type: 'result'; result: ShelvedBatchResult }
  | { type: 'complete'; successCount: number; errorCount: number; cancelled: boolean };
```

2. Add invoke wrapper function following invokeP4FstatStream pattern:
```typescript
export async function invokeP4DescribeShelvedBatch(
  changelistIds: number[],
  onProgress: (progress: ShelvedBatchProgress) => void
): Promise<string> {
  const channel = new Channel<ShelvedBatchProgress>();
  channel.onmessage = onProgress;
  return invoke<string>('p4_describe_shelved_batch', {
    changelistIds,
    ...getConnectionArgs(),
    onProgress: channel,
  });
}
```
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>TypeScript types ShelvedBatchResult and ShelvedBatchProgress exist, invokeP4DescribeShelvedBatch function exported</done>
</task>

<task type="auto">
  <name>Task 2: Replace useQueries with batch loading in useChangelists.ts</name>
  <files>src/components/ChangelistPanel/useChangelists.ts</files>
  <action>
Replace the useQueries pattern (lines 154-177) with batch loading:

1. Remove useQueries import if no longer needed elsewhere, add:
   - import { invokeP4DescribeShelvedBatch, type ShelvedBatchProgress } from '@/lib/tauri'
   - import toast from 'react-hot-toast'

2. Replace shelvedQueries useQueries block with a single useQuery:
```typescript
// Query shelved files for all numbered changelists in batch
const { data: shelvedFilesMap = new Map() } = useQuery({
  queryKey: ['p4', 'shelved-batch', numberedClIds.join(',')],
  queryFn: async () => {
    if (numberedClIds.length === 0) return new Map<number, P4ShelvedFile[]>();

    const { startOperation, updateProgress, completeOperation, addOutputLine } = useOperationStore.getState();
    const results = new Map<number, P4ShelvedFile[]>();
    const verbose = await getVerboseLogging();

    // Start operation for progress display
    startOperation('shelved-batch', `describe -S ${numberedClIds.length} CLs`);
    if (verbose) addOutputLine(`p4 describe -S ${numberedClIds.join(' ')}`, false);

    try {
      const processId = await invokeP4DescribeShelvedBatch(
        numberedClIds,
        (progress: ShelvedBatchProgress) => {
          if (progress.type === 'progress') {
            const pct = Math.round((progress.loaded / progress.total) * 100);
            updateProgress(pct, `Loading shelved files... (${progress.loaded}/${progress.total})`);
          } else if (progress.type === 'result') {
            if (progress.result.files) {
              results.set(progress.result.changelistId, progress.result.files);
            }
          } else if (progress.type === 'complete') {
            if (progress.errorCount > 0 && !progress.cancelled) {
              toast(`Loaded ${progress.successCount} of ${progress.successCount + progress.errorCount} changelists`, {
                icon: '\u26A0\uFE0F', // Warning emoji
                duration: 4000,
              });
            }
            if (verbose) {
              addOutputLine(`... loaded ${progress.successCount} CLs${progress.errorCount > 0 ? `, ${progress.errorCount} errors` : ''}`, false);
            }
            completeOperation(progress.errorCount === 0 || progress.cancelled);
          }
        }
      );

      // Store processId for cancellation - this wires to the cancel button in status bar
      // via existing useOperationStore pattern (cancel button calls ProcessManager.cancel with this ID)
      useOperationStore.getState().setProcessId(processId);

      // Wait briefly for all results to arrive (batch completes quickly)
      // The Channel delivers results, we just need to return the accumulated map
      await new Promise(resolve => setTimeout(resolve, 100));

    } catch (error) {
      if (verbose) addOutputLine(`... error: ${error}`, true);
      completeOperation(false, String(error));
    }

    return results;
  },
  enabled: isConnected && numberedClIds.length > 0,
  staleTime: 30000,
  refetchOnWindowFocus: false,
  refetchInterval: refetchIntervalValue,
});
```

3. Remove the old shelvedFilesMap useMemo that processed shelvedQueries results (lines 179-189) - the useQuery now returns the map directly.

4. Update any remaining references to shelvedQueries to use shelvedFilesMap directly.

IMPORTANT per CONTEXT.md decisions:
- Progress format: "Loading shelved files... (8/12)"
- Yellow toast on partial failure with count only
- No visual distinction on failed CLs
- Partial results kept on cancel
  </action>
  <verify>
1. npx tsc --noEmit passes
2. npm run dev starts without errors
3. No useQueries import for shelved files remains
  </verify>
  <done>
1. useChangelists uses single batch query instead of useQueries
2. Progress shows in status bar during load
3. Yellow toast on partial failure
4. Cancellation supported via ProcessManager (setProcessId wires to existing cancel button through useOperationStore)
  </done>
</task>

<task type="auto">
  <name>Task 3: Update query invalidation patterns</name>
  <files>src/components/ChangelistPanel/useChangelists.ts</files>
  <action>
Search codebase for shelved query invalidation patterns and update to match new query key.

1. Search for invalidateQueries calls referencing 'shelved':
   - Old pattern: queryKey: ['p4', 'shelved', clId]
   - New pattern: queryKey: ['p4', 'shelved-batch']

2. Common locations to check:
   - After p4_shelve calls
   - After p4_unshelve calls
   - After p4_delete_shelf calls
   - Any mutation callbacks in changelist operations

3. Update invalidation to use:
```typescript
queryClient.invalidateQueries({ queryKey: ['p4', 'shelved-batch'] })
```

This ensures shelved data refreshes after mutations trigger the batch reload instead of individual queries.

Note: The batch query key includes CL IDs joined, so invalidating ['p4', 'shelved-batch'] will match any batch query for that prefix.
  </action>
  <verify>
1. grep -r "shelved" src/ shows no individual shelved query keys
2. Shelve/unshelve operations properly invalidate batch query
  </verify>
  <done>Query invalidation patterns updated to target batch query key</done>
</task>

</tasks>

<verification>
1. npm run build succeeds
2. Opening changelist panel triggers single batch load (check output window)
3. Multiple CLs with shelved files all show their shelved files
4. Progress indicator appears in status bar during load
5. If one CL has error, others still show shelved files
6. Cancel button stops operation, partial results remain
</verification>

<success_criteria>
- Single batch call replaces N individual queries (visible in output window)
- Progress indicator shows "Loading shelved files... (X/Y)" during load
- Partial failures show yellow toast with count
- Operation is cancellable
- All BATCH requirements (01, 02, 03) met
</success_criteria>

<output>
After completion, create `.planning/phases/25-batch-optimization/25-02-SUMMARY.md`
</output>
