---
phase: 01-non-blocking-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src-tauri/src/lib.rs
  - src-tauri/src/state/mod.rs
  - src-tauri/src/state/process_manager.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/commands/process.rs
autonomous: true

must_haves:
  truths:
    - "Rust backend can spawn p4.exe and track its process handle"
    - "Rust backend can kill a tracked process by ID"
    - "App close event triggers cleanup of all tracked processes"
    - "Async commands don't block Tauri main thread"
  artifacts:
    - path: "src-tauri/src/state/process_manager.rs"
      provides: "Process handle tracking with async Mutex"
      contains: "tokio::sync::Mutex"
      exports: ["ProcessManager"]
    - path: "src-tauri/src/commands/process.rs"
      provides: "Tauri commands for process management"
      exports: ["spawn_p4_command", "kill_process", "kill_all_processes"]
    - path: "src-tauri/src/lib.rs"
      provides: "Tauri app builder with state and commands registered"
      contains: "manage(ProcessManager"
  key_links:
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/commands/process.rs"
      via: "tauri::generate_handler!"
      pattern: "spawn_p4_command.*kill_process"
    - from: "src-tauri/src/commands/process.rs"
      to: "src-tauri/src/state/process_manager.rs"
      via: "State<ProcessManager>"
      pattern: "State<.*ProcessManager>"
---

<objective>
Implement Rust backend for async process management with cancellation support

Purpose: Establish the core async infrastructure that prevents UI blocking and zombie processes
Output: Tauri commands for spawning p4.exe, tracking handles, killing processes, and cleanup on app close
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-non-blocking-foundation/01-RESEARCH.md
@.planning/phases/01-non-blocking-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProcessManager state for tracking Child handles</name>
  <files>
    src-tauri/src/state/mod.rs
    src-tauri/src/state/process_manager.rs
  </files>
  <action>
    Create src-tauri/src/state/ directory and module structure.

    Create src-tauri/src/state/process_manager.rs:

    ```rust
    use std::collections::HashMap;
    use std::process::Child;
    use tokio::sync::Mutex;
    use uuid::Uuid;

    /// Tracks active p4.exe processes for cancellation and cleanup.
    /// Uses tokio::sync::Mutex because we hold across await points.
    pub struct ProcessManager {
        processes: Mutex<HashMap<String, Child>>,
    }

    impl ProcessManager {
        pub fn new() -> Self {
            Self {
                processes: Mutex::new(HashMap::new()),
            }
        }

        /// Register a process and return its tracking ID.
        pub async fn register(&self, child: Child) -> String {
            let id = Uuid::new_v4().to_string();
            let mut processes = self.processes.lock().await;
            processes.insert(id.clone(), child);
            id
        }

        /// Kill and remove a process by ID. Returns true if found and killed.
        pub async fn kill(&self, id: &str) -> Result<bool, String> {
            let mut processes = self.processes.lock().await;
            if let Some(mut child) = processes.remove(id) {
                // On Windows, child.kill() may not kill child processes.
                // Use taskkill for reliable tree killing.
                #[cfg(target_os = "windows")]
                {
                    if let Some(pid) = child.id() {
                        let _ = std::process::Command::new("taskkill")
                            .args(["/F", "/T", "/PID", &pid.to_string()])
                            .output();
                    }
                }
                child.kill().map_err(|e| e.to_string())?;
                Ok(true)
            } else {
                Ok(false)
            }
        }

        /// Kill all tracked processes. Called on app close.
        pub async fn kill_all(&self) {
            let mut processes = self.processes.lock().await;
            for (_, mut child) in processes.drain() {
                #[cfg(target_os = "windows")]
                {
                    if let Some(pid) = child.id() {
                        let _ = std::process::Command::new("taskkill")
                            .args(["/F", "/T", "/PID", &pid.to_string()])
                            .output();
                    }
                }
                let _ = child.kill();
            }
        }

        /// Remove a process from tracking (when it completes naturally).
        pub async fn unregister(&self, id: &str) {
            let mut processes = self.processes.lock().await;
            processes.remove(id);
        }
    }

    impl Default for ProcessManager {
        fn default() -> Self {
            Self::new()
        }
    }
    ```

    Create src-tauri/src/state/mod.rs:

    ```rust
    mod process_manager;
    pub use process_manager::ProcessManager;
    ```

    Add uuid to Cargo.toml:

    ```bash
    cd src-tauri && cargo add uuid --features v4
    ```

    IMPORTANT: Use tokio::sync::Mutex (not std::sync::Mutex) because we hold the lock across await points. This is critical per RESEARCH.md Pitfall 6.
  </action>
  <verify>
    grep "tokio::sync::Mutex" src-tauri/src/state/process_manager.rs && grep "uuid" src-tauri/Cargo.toml
  </verify>
  <done>ProcessManager state struct with async Mutex for safe process tracking</done>
</task>

<task type="auto">
  <name>Task 2: Create Tauri commands for process spawning and cancellation</name>
  <files>
    src-tauri/src/commands/mod.rs
    src-tauri/src/commands/process.rs
  </files>
  <action>
    Create src-tauri/src/commands/ directory and module structure.

    Create src-tauri/src/commands/process.rs:

    ```rust
    use std::process::{Command, Stdio};
    use std::io::{BufRead, BufReader};
    use tauri::ipc::Channel;
    use tauri::State;
    use crate::state::ProcessManager;

    /// Payload sent to frontend for each stdout/stderr line.
    #[derive(Clone, serde::Serialize)]
    pub struct OutputLine {
        pub line: String,
        pub is_stderr: bool,
    }

    /// Payload sent when process completes.
    #[derive(Clone, serde::Serialize)]
    pub struct ProcessResult {
        pub exit_code: Option<i32>,
        pub success: bool,
    }

    /// Spawn p4.exe with given arguments, streaming output via Channel.
    /// Returns process ID for cancellation.
    #[tauri::command]
    pub async fn spawn_p4_command(
        args: Vec<String>,
        on_output: Channel<OutputLine>,
        state: State<'_, ProcessManager>,
    ) -> Result<String, String> {
        // Spawn p4.exe with piped stdout/stderr
        let mut child = Command::new("p4")
            .args(&args)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .map_err(|e| format!("Failed to spawn p4: {}", e))?;

        // Take stdout/stderr before moving child
        let stdout = child.stdout.take();
        let stderr = child.stderr.take();

        // Register process for tracking
        let process_id = state.register(child).await;
        let process_id_clone = process_id.clone();

        // Stream stdout in background thread
        let on_output_clone = on_output.clone();
        if let Some(stdout) = stdout {
            std::thread::spawn(move || {
                let reader = BufReader::new(stdout);
                for line in reader.lines().map_while(Result::ok) {
                    let _ = on_output_clone.send(OutputLine {
                        line,
                        is_stderr: false,
                    });
                }
            });
        }

        // Stream stderr in background thread
        if let Some(stderr) = stderr {
            std::thread::spawn(move || {
                let reader = BufReader::new(stderr);
                for line in reader.lines().map_while(Result::ok) {
                    let _ = on_output.send(OutputLine {
                        line,
                        is_stderr: true,
                    });
                }
            });
        }

        Ok(process_id_clone)
    }

    /// Execute p4 command and wait for completion (for short commands like 'p4 info').
    /// Returns stdout on success, error message on failure.
    #[tauri::command]
    pub async fn p4_command(
        args: Vec<String>,
        state: State<'_, ProcessManager>,
    ) -> Result<String, String> {
        let mut child = Command::new("p4")
            .args(&args)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .map_err(|e| format!("Failed to spawn p4: {}", e))?;

        let process_id = state.register(child).await;

        // Wait for completion - this is async-friendly because we're on thread pool
        // Note: We need to get the child back to wait on it
        // Actually, since we moved child into register, we need a different approach
        // Let's use a simpler pattern for short commands

        let output = Command::new("p4")
            .args(&args)
            .output()
            .map_err(|e| format!("Failed to execute p4: {}", e))?;

        state.unregister(&process_id).await;

        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            Err(String::from_utf8_lossy(&output.stderr).to_string())
        }
    }

    /// Kill a tracked process by ID.
    #[tauri::command]
    pub async fn kill_process(
        process_id: String,
        state: State<'_, ProcessManager>,
    ) -> Result<bool, String> {
        state.kill(&process_id).await
    }

    /// Kill all tracked processes. Called on app close.
    #[tauri::command]
    pub async fn kill_all_processes(
        state: State<'_, ProcessManager>,
    ) -> Result<(), String> {
        state.kill_all().await;
        Ok(())
    }
    ```

    Create src-tauri/src/commands/mod.rs:

    ```rust
    mod process;
    pub use process::*;
    ```

    NOTE: All commands return Result<T, String> per RESEARCH.md Pitfall 7.
    NOTE: spawn_p4_command uses std::thread for blocking IO (reading pipes) to avoid blocking Tauri's async runtime.
  </action>
  <verify>
    grep "spawn_p4_command" src-tauri/src/commands/process.rs && grep "kill_process" src-tauri/src/commands/process.rs
  </verify>
  <done>Tauri commands for spawning, killing, and batch-killing processes</done>
</task>

<task type="auto">
  <name>Task 3: Wire up state and commands in lib.rs with close handler</name>
  <files>
    src-tauri/src/lib.rs
  </files>
  <action>
    Update src-tauri/src/lib.rs to:
    1. Declare state and commands modules
    2. Register ProcessManager state
    3. Register all Tauri commands
    4. Add window close handler to kill all processes

    ```rust
    mod commands;
    mod state;

    use state::ProcessManager;
    use tauri::Manager;

    #[cfg_attr(mobile, tauri::mobile_entry_point)]
    pub fn run() {
        tauri::Builder::default()
            .plugin(tauri_plugin_shell::init())
            .manage(ProcessManager::new())
            .invoke_handler(tauri::generate_handler![
                commands::spawn_p4_command,
                commands::p4_command,
                commands::kill_process,
                commands::kill_all_processes,
            ])
            .setup(|app| {
                // Get process manager for cleanup
                let process_manager = app.state::<ProcessManager>();

                // Listen for window close to cleanup processes
                let window = app.get_webview_window("main").unwrap();
                let pm = process_manager.inner().clone();

                window.on_window_event(move |event| {
                    if let tauri::WindowEvent::CloseRequested { .. } = event {
                        // Kill all tracked processes synchronously
                        // Use block_on since this is a sync callback
                        let pm_clone = pm.clone();
                        tauri::async_runtime::block_on(async move {
                            pm_clone.kill_all().await;
                        });
                    }
                });

                Ok(())
            })
            .run(tauri::generate_context!())
            .expect("error while running tauri application");
    }
    ```

    Wait - ProcessManager doesn't implement Clone. We need to wrap it in Arc for sharing.

    Update src-tauri/src/state/process_manager.rs to use Arc internally or wrap in Arc at registration.

    Actually, Tauri's State already handles this - it uses Arc internally. But we need to clone the inner value for the event handler.

    Better approach: Store Arc<ProcessManager> and use .inner() to get the Arc.

    Actually, simplest fix: Make ProcessManager Clone by wrapping Mutex in Arc:

    Update process_manager.rs:

    ```rust
    use std::sync::Arc;

    #[derive(Clone)]
    pub struct ProcessManager {
        processes: Arc<Mutex<HashMap<String, Child>>>,
    }

    impl ProcessManager {
        pub fn new() -> Self {
            Self {
                processes: Arc::new(Mutex::new(HashMap::new())),
            }
        }
        // ... rest stays the same, just use self.processes directly
    }
    ```

    This allows cloning the ProcessManager for the window event handler.
  </action>
  <verify>
    grep "manage(ProcessManager" src-tauri/src/lib.rs && grep "spawn_p4_command" src-tauri/src/lib.rs && grep "CloseRequested" src-tauri/src/lib.rs
  </verify>
  <done>ProcessManager registered as Tauri state, all commands registered, close handler kills processes</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Compile check:
   ```bash
   cd src-tauri && cargo check
   ```
   Should complete without errors.

2. Build check:
   ```bash
   npm run tauri build
   ```
   Should compile Rust backend successfully.

3. Command verification (if p4 is installed):
   - Launch app with `npm run tauri dev`
   - Open DevTools console
   - Run: `await window.__TAURI__.core.invoke('p4_command', { args: ['info'] })`
   - Should return p4 server info or connection error (not a crash)
</verification>

<success_criteria>
- ProcessManager uses tokio::sync::Mutex for async safety
- Windows uses taskkill fallback for reliable process tree killing
- All commands return Result<T, String>
- Window close handler triggers kill_all_processes
- Rust code compiles without warnings
</success_criteria>

<output>
After completion, create `.planning/phases/01-non-blocking-foundation/01-02-SUMMARY.md`
</output>
