---
phase: 10-bug-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/commands/p4.rs
  - src-tauri/src/lib.rs
  - src/lib/tauri.ts
  - src/hooks/useShelvedFiles.ts
autonomous: true

must_haves:
  truths:
    - "User can unshelve files to a specific target changelist (not forced to source CL)"
    - "User sees resolve notification after unshelving files that create conflicts"
  artifacts:
    - path: "src-tauri/src/commands/p4.rs"
      provides: "p4_unshelve with separate source/target CL params, p4_resolve_preview command"
      contains: "source_changelist_id"
    - path: "src/lib/tauri.ts"
      provides: "Updated invokeP4Unshelve with targetChangelistId, new invokeP4ResolvePreview"
      contains: "targetChangelistId"
    - path: "src/hooks/useShelvedFiles.ts"
      provides: "useUnshelve passes same CL as both source and target, checks for resolves after unshelve"
      contains: "invokeP4ResolvePreview"
  key_links:
    - from: "useShelvedFiles.ts"
      to: "invokeP4Unshelve"
      via: "passes changelistId as both source and target"
      pattern: "invokeP4Unshelve.*changelistId.*changelistId"
    - from: "useShelvedFiles.ts"
      to: "invokeP4ResolvePreview"
      via: "checks for unresolved files after unshelve succeeds"
      pattern: "invokeP4ResolvePreview"
    - from: "p4.rs p4_unshelve"
      to: "p4 unshelve -s SRC -c TGT"
      via: "separate source and target changelist params"
      pattern: "source_changelist_id.*target_changelist_id"
---

<objective>
Fix unshelve to support target changelist (BUGF-03) and add resolve detection after unshelve (BUGF-04).

Purpose: Users need to unshelve to specific CLs and be warned about conflicts that need resolution.
Output: Updated Rust backend with separate source/target CL params, new resolve preview command, and frontend integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-bug-fixes/10-RESEARCH.md

@src-tauri/src/commands/p4.rs
@src-tauri/src/lib.rs
@src/lib/tauri.ts
@src/hooks/useShelvedFiles.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add target CL param to unshelve + resolve preview command in Rust</name>
  <files>src-tauri/src/commands/p4.rs, src-tauri/src/lib.rs</files>
  <action>
**p4.rs — Update p4_unshelve:**

1. Rename the `changelist_id` parameter to `source_changelist_id`.
2. Add a new parameter `target_changelist_id: i32` after `source_changelist_id`.
3. Update the command construction: `-s` uses `source_changelist_id`, `-c` uses `target_changelist_id`.
4. Keep all other logic (file_paths, connection args, output handling) unchanged.

**p4.rs — Add p4_resolve_preview:**

Add a new Tauri command that runs `p4 resolve -n` to list files needing resolution without actually resolving:

```rust
#[tauri::command]
pub async fn p4_resolve_preview(
    server: Option<String>,
    user: Option<String>,
    client: Option<String>,
) -> Result<Vec<String>, String> {
    let mut cmd = Command::new("p4");
    apply_connection_args(&mut cmd, &server, &user, &client);
    cmd.args(["resolve", "-n"]);

    let output = cmd.output()
        .map_err(|e| format!("Failed to execute p4 resolve -n: {}", e))?;

    let stdout = String::from_utf8_lossy(&output.stdout);

    // Parse output: lines like "//depot/path - merging ..." or "//depot/path - must resolve ..."
    let files: Vec<String> = stdout
        .lines()
        .filter(|line| !line.is_empty())
        .map(|line| {
            // Extract depot path (everything before " - ")
            line.split(" - ").next().unwrap_or(line).trim().to_string()
        })
        .collect();

    Ok(files)
}
```

Note: `p4 resolve -n` returns exit code 0 even when there are files to resolve, and returns empty output when nothing needs resolving. Don't check exit status for error — empty result means no conflicts.

**lib.rs — Register new command:**

Add `p4_resolve_preview` to the `.invoke_handler(tauri::generate_handler![...])` list alongside the existing commands. The `p4_unshelve` is already registered, it just needs its signature updated.
  </action>
  <verify>
Run `cargo check` in `src-tauri/` — no compilation errors. Verify p4_unshelve has two separate changelist params. Verify p4_resolve_preview is registered in lib.rs.
  </verify>
  <done>p4_unshelve accepts separate source and target CL IDs. p4_resolve_preview runs `p4 resolve -n` and returns list of files needing resolution.</done>
</task>

<task type="auto">
  <name>Task 2: Update frontend unshelve to use target CL + detect conflicts</name>
  <files>src/lib/tauri.ts, src/hooks/useShelvedFiles.ts</files>
  <action>
**tauri.ts — Update invokeP4Unshelve:**

1. Add `targetChangelistId` parameter (after `changelistId`):
   ```typescript
   export async function invokeP4Unshelve(
     changelistId: number,
     targetChangelistId: number,
     filePaths?: string[],
     server?: string,
     user?: string,
     client?: string
   ): Promise<string> {
     return invoke<string>('p4_unshelve', {
       sourceChangelistId: changelistId,
       targetChangelistId,
       filePaths, server, user, client
     });
   }
   ```

2. Add new `invokeP4ResolvePreview` function:
   ```typescript
   export async function invokeP4ResolvePreview(
     server?: string,
     user?: string,
     client?: string
   ): Promise<string[]> {
     return invoke<string[]>('p4_resolve_preview', { server, user, client });
   }
   ```

**useShelvedFiles.ts — Update useUnshelve:**

1. Add import for `invokeP4ResolvePreview` from `@/lib/tauri`.
2. In the `mutationFn`, update the `invokeP4Unshelve` call to pass `changelistId` as both source AND target (preserves current behavior — unshelve back to same CL):
   ```typescript
   return invokeP4Unshelve(
     changelistId,
     changelistId,  // target = source (same CL)
     filePaths,
     p4port ?? undefined,
     p4user ?? undefined,
     p4client ?? undefined
   );
   ```
3. In the `onSuccess` callback, after the existing toast and query invalidation, add resolve detection:
   ```typescript
   // Check for files needing resolution
   try {
     const unresolvedFiles = await invokeP4ResolvePreview(
       p4port ?? undefined,
       p4user ?? undefined,
       p4client ?? undefined
     );
     if (unresolvedFiles.length > 0) {
       addOutputLine(`${unresolvedFiles.length} file(s) need resolution`, false);
       toast(`${unresolvedFiles.length} file(s) need resolution after unshelve`, {
         icon: '⚠️',
         duration: 5000,
       });
     }
   } catch {
     // Non-blocking: if resolve check fails, don't block the unshelve success
   }
   ```

Note: For Phase 10, the resolve notification is informational only (toast + output log). Phase 15 will implement the full resolve dialog with external merge tool integration. This is the correct approach per the research: "Show conflict list dialog with 'Configure Merge Tool' button, don't block user."

The `onSuccess` callback needs access to `p4port`, `p4user`, `p4client`, and `addOutputLine`. These are already in scope from the hook's closure. However, since `onSuccess` is called asynchronously, capture the connection values at mutation time by returning them from `mutationFn` or reading them from the store. The simplest approach: read from `useConnectionStore.getState()` inside `onSuccess` (same pattern used in `useShelvedFilesQuery`).
  </action>
  <verify>
Run `npm run build` — no TypeScript errors. Verify tauri.ts has invokeP4Unshelve with targetChangelistId and invokeP4ResolvePreview. Verify useShelvedFiles.ts calls invokeP4Unshelve with two CL params and checks for resolves in onSuccess.
  </verify>
  <done>Frontend passes target CL to unshelve backend. After successful unshelve, checks for unresolved files and shows warning toast if conflicts exist.</done>
</task>

</tasks>

<verification>
1. `cargo check` in src-tauri/ succeeds
2. `npm run build` succeeds with no errors
3. p4_unshelve in p4.rs has `source_changelist_id` and `target_changelist_id` as separate params
4. p4_resolve_preview exists in p4.rs and is registered in lib.rs
5. invokeP4Unshelve in tauri.ts accepts targetChangelistId
6. invokeP4ResolvePreview in tauri.ts is exported
7. useUnshelve in useShelvedFiles.ts passes changelistId as both source and target
8. useUnshelve onSuccess checks for unresolved files after unshelve
</verification>

<success_criteria>
- Unshelve Rust command accepts separate source and target changelist IDs
- Resolve preview command returns list of files needing resolution
- Frontend passes same CL as source and target (preserves current UX, enables future target CL picker)
- After unshelve, user sees toast warning if files need resolution
- Both cargo check and npm run build pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-bug-fixes/10-02-SUMMARY.md`
</output>
