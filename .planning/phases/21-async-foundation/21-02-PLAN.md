---
phase: 21-async-foundation
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - src-tauri/src/commands/p4/parsing.rs
  - src-tauri/src/commands/p4/p4handlers.rs
autonomous: true

must_haves:
  truths:
    - "All p4 commands in p4handlers.rs use tokio::process::Command instead of std::process::Command"
    - "apply_connection_args accepts &mut tokio::process::Command instead of &mut std::process::Command"
    - "All .output() calls are awaited (.output().await) for non-blocking execution"
    - "p4_sync uses tokio::spawn for stdout/stderr streaming instead of std::thread::spawn"
    - "Commands that use .spawn() + .wait_with_output() use tokio equivalents"
    - "Existing p4 commands continue to work with no functional changes"
  artifacts:
    - path: "src-tauri/src/commands/p4/parsing.rs"
      provides: "apply_connection_args accepting tokio::process::Command"
      contains: "tokio::process::Command"
    - path: "src-tauri/src/commands/p4/p4handlers.rs"
      provides: "All p4 commands using async process execution"
      contains: "tokio::process::Command"
  key_links:
    - from: "src-tauri/src/commands/p4/p4handlers.rs"
      to: "src-tauri/src/commands/p4/parsing.rs"
      via: "apply_connection_args with tokio::process::Command"
      pattern: "apply_connection_args"
    - from: "src-tauri/src/commands/p4/p4handlers.rs"
      to: "src-tauri/src/state/process_manager.rs"
      via: "state.register(child) in p4_sync"
      pattern: "state\\.register"
---

<objective>
Migrate all p4 handler commands from std::process::Command to tokio::process::Command for fully non-blocking async execution.

Purpose: p4handlers.rs contains ~42 instances of std::process::Command that block tokio worker threads. This migration completes the async foundation so every p4 operation is non-blocking, enabling the app to remain responsive during concurrent operations on large depots.

Output: All p4 commands use tokio::process::Command with awaited .output() calls. apply_connection_args updated for new Command type. p4_sync streaming uses tokio::spawn.
</objective>

<execution_context>
@C:\Users\a\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\a\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/21-async-foundation/21-01-SUMMARY.md
@src-tauri/src/commands/p4/parsing.rs
@src-tauri/src/commands/p4/p4handlers.rs
@src-tauri/src/commands/p4/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update apply_connection_args and migrate p4handlers.rs to tokio::process</name>
  <files>src-tauri/src/commands/p4/parsing.rs, src-tauri/src/commands/p4/p4handlers.rs</files>
  <action>
**Step 1: Update parsing.rs**

Change the `apply_connection_args` function signature from `std::process::Command` to `tokio::process::Command`:
- Change line: `cmd: &mut std::process::Command,` to `cmd: &mut tokio::process::Command,`
- The function body stays identical — tokio::process::Command has the same env/args API as std::process::Command

**Step 2: Migrate p4handlers.rs imports**

Replace the imports at the top of the file:
- Remove: `use std::io::{BufRead, BufReader, Write};` and `use std::process::{Command, Stdio};`
- Add: `use tokio::process::Command;` and `use std::process::Stdio;` and `use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};`

Note: Stdio comes from std::process (tokio re-exports it but std::process::Stdio is the canonical type). BufReader and line reading use tokio async versions.

**Step 3: Mechanical migration of all p4 commands**

For every command function that uses `Command::new("p4")` followed by `.output()`:
- The `Command::new("p4")` call stays the same (now resolves to tokio::process::Command from import)
- Change every `.output()` to `.output().await`
- This applies to these functions (exhaustive list):
  - `p4_info` — `.output()` to `.output().await`
  - `p4_fstat` — `.output()` to `.output().await`
  - `p4_opened` — `.output()` to `.output().await`
  - `p4_changes` — `.output()` to `.output().await`
  - `p4_edit` — `.output()` to `.output().await` (note: calls p4_fstat internally which is already async)
  - `p4_revert` — `.output()` to `.output().await`
  - `p4_submit` — `.output()` to `.output().await` (two .output() calls in different branches)
  - `p4_create_change` — two commands:
    1. First `cmd.output()` to `cmd.output().await`
    2. Second uses `.spawn()` + `.wait_with_output()`: Change to tokio equivalents:
       - `.spawn()` stays (tokio::process::Command.spawn())
       - Change `stdin.write_all(...)` to `stdin.write_all(...).await` (uses AsyncWriteExt)
       - Change `child.wait_with_output()` to `child.wait_with_output().await`
  - `p4_delete_change` — `.output()` to `.output().await`
  - `p4_reopen` — `.output()` to `.output().await`
  - `p4_filelog` — `.output()` to `.output().await`
  - `p4_print_to_file` — `.output()` to `.output().await`
  - `p4_print_content` — two `.output()` calls to `.output().await`
  - `p4_annotate` — two `.output()` calls to `.output().await`
  - `launch_diff_tool` — `.spawn()` stays as fire-and-forget (tokio::process::Command.spawn())
  - `p4_changes_submitted` — `.output()` to `.output().await`
  - `p4_shelve` — `.output()` to `.output().await`
  - `p4_describe_shelved` — `.output()` to `.output().await`
  - `p4_describe` — `.output()` to `.output().await`
  - `p4_unshelve` — `.output()` to `.output().await`
  - `p4_delete_shelf` — `.output()` to `.output().await`
  - `p4_reconcile_preview` — `.output()` to `.output().await`
  - `p4_reconcile_apply` — `.output()` to `.output().await`
  - `p4_resolve_preview` — `.output()` to `.output().await`
  - `p4_files` — `.output()` to `.output().await`
  - `p4_list_streams` — `.output()` to `.output().await`
  - `p4_get_client_spec` — `.output()` to `.output().await`
  - `p4_update_client_stream` — two commands: first `.output()` to `.output().await`, second `.spawn()` + `.wait_with_output()` to async equivalents (same pattern as p4_create_change)
  - `p4_depots` — `.output()` to `.output().await`
  - `p4_dirs` — `.output()` to `.output().await`
  - `p4_fstat_unresolved` — `.output()` to `.output().await`
  - `p4_resolve_accept` — `.output()` to `.output().await`
  - `p4_list_workspaces` — `.output()` to `.output().await`
  - `p4_test_connection` — `.output()` to `.output().await`

**Step 4: Migrate p4_sync streaming**

In `p4_sync`, change:
- `Command::new("p4")` — now tokio::process::Command
- `.spawn()` — tokio::process::Command.spawn()
- Replace two `std::thread::spawn` blocks with `tokio::spawn` async blocks:
  ```rust
  if let Some(stdout) = stdout {
      tokio::spawn(async move {
          let mut lines = BufReader::new(stdout).lines();
          while let Ok(Some(line)) = lines.next_line().await {
              if let Some(progress) = parse_sync_line(&line) {
                  let _ = on_progress_clone.send(progress);
              }
          }
      });
  }
  ```
  Same for stderr reading block.

**Step 5: Migrate launch_merge_tool**

In `launch_merge_tool`:
- All `.output()` calls become `.output().await`
- The `spawn_blocking` block that runs the merge tool uses `std::process::Command` — this is INTENTIONAL. Keep it as `std::process::Command` because it runs inside `spawn_blocking`. Add a `use std::process::Command as StdCommand;` import at the top OR qualify it inline as `std::process::Command::new(&merge_tool_clone)`. The merge tool needs to block (waiting for user to close merge tool) which is why it uses spawn_blocking.
- The p4 commands in launch_merge_tool (p4 fstat, two p4 print calls) should use tokio::process::Command with `.output().await`

**Step 6: Update update_changelist_description helper**

The `update_changelist_description` helper function (called by p4_submit and p4_edit_change_description) is a synchronous function. Check if it exists and uses std::process::Command. If so, either:
- Make it async and change callers to `.await` it, OR
- Wrap it in spawn_blocking

Preferred: Make it async since all callers are already async.

**IMPORTANT**: Do NOT change the `parse_sync_line` import or any parsing functions — they remain synchronous string processing, which is correct.
  </action>
  <verify>
Run `cargo build` from src-tauri directory. The entire project must compile without errors.

Verify: `grep -c "std::process::Command" src-tauri/src/commands/p4/p4handlers.rs` returns 0 or 1 (only the std::process::Command inside spawn_blocking for merge tool).
Verify: `grep -c "std::thread::spawn" src-tauri/src/commands/p4/p4handlers.rs` returns 0 (no blocking threads).
Verify: `grep -c ".output().await" src-tauri/src/commands/p4/p4handlers.rs` shows many matches (one per command).
Verify: `grep "tokio::process::Command" src-tauri/src/commands/p4/parsing.rs` confirms updated type.
  </verify>
  <done>
All p4 commands in p4handlers.rs use tokio::process::Command with .output().await. apply_connection_args accepts tokio::process::Command. p4_sync streaming uses tokio::spawn. launch_merge_tool keeps std::process::Command inside spawn_blocking (intentional). The entire project compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` passes from src-tauri directory with no errors
2. Zero instances of `std::process::Command::new("p4")` remain in p4handlers.rs (except inside spawn_blocking)
3. Zero instances of `std::thread::spawn` remain in p4handlers.rs
4. `apply_connection_args` accepts `&mut tokio::process::Command`
5. All `.output()` calls are `.output().await`
6. p4_sync uses `tokio::spawn` for streaming readers
7. launch_merge_tool's `spawn_blocking` block still uses `std::process::Command` (correct — it intentionally blocks)
</verification>

<success_criteria>
Every p4 command executes non-blocking via tokio::process. The app can run multiple p4 commands concurrently without blocking the tokio runtime. Existing command behavior is unchanged — same arguments, same parsing, same return types.
</success_criteria>

<output>
After completion, create `.planning/phases/21-async-foundation/21-02-SUMMARY.md`
</output>
