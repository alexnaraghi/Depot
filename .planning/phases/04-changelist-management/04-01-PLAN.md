---
phase: 04-changelist-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/commands/p4.rs
  - src/lib/tauri.ts
  - src/types/p4.ts
autonomous: true

must_haves:
  truths:
    - "Frontend can invoke create-changelist, delete-changelist, reopen-files, and edit-description commands"
    - "Rust backend executes p4 change -o/-i for create, p4 change -d for delete, p4 reopen -c for file movement, and p4 change -o/-i for description edit"
  artifacts:
    - path: "src-tauri/src/commands/p4.rs"
      provides: "p4_create_change, p4_delete_change, p4_reopen, p4_edit_change_description commands"
      contains: "p4_create_change"
    - path: "src/lib/tauri.ts"
      provides: "invokeP4CreateChange, invokeP4DeleteChange, invokeP4Reopen, invokeP4EditChangeDescription wrappers"
      contains: "invokeP4CreateChange"
  key_links:
    - from: "src/lib/tauri.ts"
      to: "src-tauri/src/commands/p4.rs"
      via: "Tauri invoke bindings"
      pattern: "invoke.*p4_create_change"
---

<objective>
Add Rust backend commands and TypeScript Tauri bindings for changelist CRUD operations and file movement.

Purpose: Phase 04 requires create, edit, delete changelist and move-files-between-changelists. The backend commands must exist before UI can be built.
Output: Four new Tauri commands (p4_create_change, p4_delete_change, p4_reopen, p4_edit_change_description) with frontend invoke wrappers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-changelist-management/04-RESEARCH.md

Key existing patterns:
- `update_changelist_description()` in p4.rs (line 583) already does p4 change -o/-i form parsing — reuse this pattern
- `apply_connection_args()` helper for server/user/client args
- `p4_edit()` already handles reopen detection in stdout parsing
- All commands accept optional server/user/client for connection override
- Frontend wrappers in tauri.ts follow `invokeP4Xxx` naming convention
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Rust backend commands for changelist CRUD and file reopen</name>
  <files>src-tauri/src/commands/p4.rs, src-tauri/src/main.rs</files>
  <action>
Add four new Tauri commands to p4.rs:

1. **`p4_create_change(description, server, user, client) -> Result<i32, String>`**
   - Get template: `p4 change -o` (with connection args)
   - Replace description field in the form using the same pattern as `update_changelist_description()` (line 583-651)
   - Remove the `Files:` section from the template (new changelist should have no files)
   - Submit form: `p4 change -i` via stdin pipe
   - Parse stdout for "Change NNNNN created." to extract changelist number
   - Return the new changelist ID

2. **`p4_delete_change(changelist, server, user, client) -> Result<(), String>`**
   - Execute: `p4 change -d {changelist}` (with connection args)
   - Check exit status, return stderr on failure
   - Simple command, no form parsing needed

3. **`p4_reopen(paths, changelist, server, user, client) -> Result<Vec<String>, String>`**
   - Execute: `p4 reopen -c {changelist} {paths...}` (with connection args)
   - Parse stdout: lines matching pattern `//depot/path#rev - reopened; change NNN`
   - Return list of successfully moved depot paths
   - This is preferred over p4_edit for explicit file movement intent

4. **`p4_edit_change_description(changelist, description, server, user, client) -> Result<(), String>`**
   - Make the existing private `update_changelist_description()` function into a public Tauri command
   - Wrap the existing function, adding the `#[tauri::command]` attribute
   - Keep the existing form-parsing logic unchanged

Register all four new commands in `main.rs` invoke_handler list.

Note: Use `use std::io::Write;` which is already imported in the submit function scope — move it to file-level import if not already there.
  </action>
  <verify>
Run `cd src-tauri && cargo check` — must compile with no errors.
Verify all four commands are registered in main.rs invoke_handler.
  </verify>
  <done>Four new Tauri commands compile and are registered: p4_create_change returns i32, p4_delete_change returns (), p4_reopen returns Vec<String>, p4_edit_change_description returns ().</done>
</task>

<task type="auto">
  <name>Task 2: Add TypeScript Tauri invoke wrappers</name>
  <files>src/lib/tauri.ts</files>
  <action>
Add four new invoke wrapper functions to tauri.ts, following the existing pattern (e.g., `invokeP4Submit`):

1. **`invokeP4CreateChange(description: string, server?: string, user?: string, client?: string): Promise<number>`**
   - Invokes `p4_create_change`

2. **`invokeP4DeleteChange(changelist: number, server?: string, user?: string, client?: string): Promise<void>`**
   - Invokes `p4_delete_change`

3. **`invokeP4Reopen(paths: string[], changelist: number, server?: string, user?: string, client?: string): Promise<string[]>`**
   - Invokes `p4_reopen`

4. **`invokeP4EditChangeDescription(changelist: number, description: string, server?: string, user?: string, client?: string): Promise<void>`**
   - Invokes `p4_edit_change_description`

Each function should have a JSDoc comment matching the existing style (single-line purpose).
  </action>
  <verify>
Run `npx tsc --noEmit` — must pass with no type errors.
  </verify>
  <done>Four invoke wrappers exist in tauri.ts with proper TypeScript signatures matching Rust command signatures.</done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` passes
2. `npx tsc --noEmit` passes
3. All four Rust commands are registered in main.rs
4. All four TypeScript wrappers exist in tauri.ts
</verification>

<success_criteria>
- Four new P4 backend commands compile and are registered
- Four corresponding TypeScript invoke wrappers exist with correct signatures
- Existing commands are not broken (cargo check + tsc pass)
</success_criteria>

<output>
After completion, create `.planning/phases/04-changelist-management/04-01-SUMMARY.md`
</output>
