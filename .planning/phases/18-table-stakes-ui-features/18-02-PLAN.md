---
phase: 18-table-stakes-ui-features
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/commands/p4.rs
  - src-tauri/src/lib.rs
  - src/lib/tauri.ts
autonomous: true

must_haves:
  truths:
    - "Backend command returns submitted changelist metadata and file list"
    - "File list includes depot path, revision, action, and file type"
    - "Diffs are suppressed to avoid memory/timeout issues with large CLs"
  artifacts:
    - path: "src-tauri/src/commands/p4.rs"
      provides: "p4_describe command with -s flag"
      contains: "p4_describe"
    - path: "src/lib/tauri.ts"
      provides: "invokeP4Describe TypeScript wrapper"
      contains: "invokeP4Describe"
  key_links:
    - from: "src/lib/tauri.ts"
      to: "src-tauri/src/commands/p4.rs"
      via: "Tauri invoke"
      pattern: "invoke.*p4_describe"
---

<objective>
Add p4_describe backend command for fetching submitted changelist file lists.

Purpose: Enables CLFILE-01, CLFILE-02, CLFILE-03 requirements. Addresses p4_describe tech debt noted in RevisionDetailView.tsx TODO comment.

Output: New backend command and TypeScript wrapper for fetching complete file list of any submitted changelist.
</objective>

<execution_context>
@C:\Users\a\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\a\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-table-stakes-ui-features/18-RESEARCH.md

# Existing patterns to follow
@src-tauri/src/commands/p4.rs — Existing p4 commands pattern, parse_ztag_records function
@src/lib/tauri.ts — Tauri invoke wrappers with getConnectionArgs()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add p4_describe command to Rust backend</name>
  <files>src-tauri/src/commands/p4.rs</files>
  <action>
Add new structs for describe output near other P4 result types (around line 50):

```rust
/// File info from p4 describe output
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct P4DescribeFile {
    pub depot_path: String,
    pub revision: i32,
    pub action: String,
    pub file_type: String,
}

/// Result of p4 describe for a submitted changelist
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct P4ChangelistDescription {
    pub id: i32,
    pub user: String,
    pub client: String,
    pub time: i64,
    pub description: String,
    pub status: String,
    pub files: Vec<P4DescribeFile>,
}
```

Add the p4_describe command after the existing p4_describe_shelved command (around line 1700):

```rust
/// Describe a submitted changelist (metadata and file list, no diffs)
/// Uses -s flag to suppress diff output for performance with large changelists
#[tauri::command]
pub async fn p4_describe(
    changelist_id: i32,
    server: Option<String>,
    user: Option<String>,
    client: Option<String>,
) -> Result<P4ChangelistDescription, String> {
    let mut cmd = Command::new("p4");
    apply_connection_args(&mut cmd, &server, &user, &client);
    // -ztag for structured output, -s to suppress diffs (critical for large CLs)
    cmd.args(["-ztag", "describe", "-s", &changelist_id.to_string()]);

    let output = cmd
        .output()
        .map_err(|e| format!("Failed to execute p4 describe: {}", e))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(stderr.to_string());
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    parse_describe_output(&stdout, changelist_id)
}

/// Parse p4 describe -ztag output into P4ChangelistDescription
/// The output contains numbered fields for each file:
/// depotFile0, rev0, action0, type0, depotFile1, rev1, action1, type1, ...
fn parse_describe_output(output: &str, changelist_id: i32) -> Result<P4ChangelistDescription, String> {
    let records = parse_ztag_records(output);

    if records.is_empty() {
        return Err(format!("No data returned for changelist {}", changelist_id));
    }

    let record = &records[0];

    // Extract basic metadata
    let user = record.get("user").cloned().unwrap_or_default();
    let client = record.get("client").cloned().unwrap_or_default();
    let time_str = record.get("time").cloned().unwrap_or_default();
    let time = time_str.parse::<i64>().unwrap_or(0);
    let description = record.get("desc").cloned().unwrap_or_default();
    let status = record.get("status").cloned().unwrap_or_else(|| "submitted".to_string());

    // Extract files from numbered fields
    let mut files = Vec::new();
    let mut index = 0;

    loop {
        let depot_file_key = format!("depotFile{}", index);
        let rev_key = format!("rev{}", index);
        let action_key = format!("action{}", index);
        let type_key = format!("type{}", index);

        if let Some(depot_path) = record.get(&depot_file_key) {
            let revision = record
                .get(&rev_key)
                .and_then(|r| r.parse::<i32>().ok())
                .unwrap_or(0);
            let action = record.get(&action_key).cloned().unwrap_or_default();
            let file_type = record.get(&type_key).cloned().unwrap_or_default();

            files.push(P4DescribeFile {
                depot_path: depot_path.clone(),
                revision,
                action,
                file_type,
            });
            index += 1;
        } else {
            break;
        }
    }

    Ok(P4ChangelistDescription {
        id: changelist_id,
        user,
        client,
        time,
        description,
        status,
        files,
    })
}
```

Note: The parse_ztag_records function already exists in the file. Use the same pattern as other commands.
  </action>
  <verify>Run `cargo build` in src-tauri directory to verify Rust compiles</verify>
  <done>p4_describe command added to Rust backend with P4DescribeFile and P4ChangelistDescription structs</done>
</task>

<task type="auto">
  <name>Task 2: Register command and add TypeScript wrapper</name>
  <files>src-tauri/src/lib.rs, src/lib/tauri.ts</files>
  <action>
In src-tauri/src/lib.rs, add p4_describe to the invoke_handler list:

Find the invoke_handler section (large list of command names) and add `commands::p4::p4_describe` in alphabetical order near other p4_describe* commands.

In src/lib/tauri.ts:

Add TypeScript interfaces near other P4 types (around line 50):

```typescript
/**
 * File info from p4 describe output
 */
export interface P4DescribeFile {
  depotPath: string;
  revision: number;
  action: string;
  fileType: string;
}

/**
 * Result of p4 describe for a submitted changelist
 */
export interface P4ChangelistDescription {
  id: number;
  user: string;
  client: string;
  time: number;
  description: string;
  status: string;
  files: P4DescribeFile[];
}
```

Add the invoke wrapper function near other P4 invoke functions:

```typescript
/**
 * Describe a submitted changelist (metadata and file list)
 * Uses -s flag to suppress diffs for performance
 */
export async function invokeP4Describe(
  changelistId: number
): Promise<P4ChangelistDescription> {
  return invoke<P4ChangelistDescription>('p4_describe', {
    changelistId,
    ...getConnectionArgs(),
  });
}
```
  </action>
  <verify>
Run `cargo build` in src-tauri to verify Rust compiles with new command registration.
Run `npm run build` to verify TypeScript compiles.
  </verify>
  <done>p4_describe command registered in lib.rs, TypeScript wrapper invokeP4Describe added to tauri.ts</done>
</task>

</tasks>

<verification>
1. `cargo build` in src-tauri succeeds
2. `npm run build` succeeds
3. Manual test: Query a known submitted changelist and verify it returns metadata and file list
</verification>

<success_criteria>
- Backend p4_describe command exists and returns P4ChangelistDescription
- TypeScript wrapper invokeP4Describe is available
- Diffs are suppressed via -s flag (critical for performance with large CLs)
- Command is registered in lib.rs invoke_handler
</success_criteria>

<output>
After completion, create `.planning/phases/18-table-stakes-ui-features/18-02-SUMMARY.md`
</output>
