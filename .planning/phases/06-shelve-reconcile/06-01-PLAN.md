---
phase: 06-shelve-reconcile
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/commands/p4.rs
  - src/lib/tauri.ts
autonomous: true

must_haves:
  truths:
    - "Rust backend can shelve files in a changelist"
    - "Rust backend can describe shelved files for a changelist"
    - "Rust backend can unshelve files from a changelist"
    - "Rust backend can delete a shelf from a changelist"
    - "Rust backend can preview reconcile (dry run) and apply reconcile for selected paths"
    - "TypeScript invoke wrappers exist for all six new commands"
  artifacts:
    - path: "src-tauri/src/commands/p4.rs"
      provides: "p4_shelve, p4_describe_shelved, p4_unshelve, p4_delete_shelf, p4_reconcile_preview, p4_reconcile_apply commands"
      contains: "pub async fn p4_shelve"
    - path: "src/lib/tauri.ts"
      provides: "invokeP4Shelve, invokeP4DescribeShelved, invokeP4Unshelve, invokeP4DeleteShelf, invokeP4ReconcilePreview, invokeP4ReconcileApply"
      contains: "invokeP4Shelve"
  key_links:
    - from: "src/lib/tauri.ts"
      to: "src-tauri/src/commands/p4.rs"
      via: "Tauri invoke bridge"
      pattern: "invoke.*p4_shelve"
---

<objective>
Add Rust backend commands for shelve, unshelve, delete shelf, describe shelved files, reconcile preview, and reconcile apply. Add TypeScript invoke wrappers for all six commands.

Purpose: Backend foundation for Phase 06 shelve/reconcile features. All UI plans depend on these commands.
Output: Six new Tauri commands registered in p4.rs, six new invoke wrappers in tauri.ts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-shelve-reconcile/06-RESEARCH.md

@src-tauri/src/commands/p4.rs
@src/lib/tauri.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add six Rust backend commands for shelve and reconcile</name>
  <files>src-tauri/src/commands/p4.rs, src-tauri/src/lib.rs</files>
  <action>
Add six new Tauri async commands to p4.rs, following the existing pattern (accept optional server/user/client args, use apply_connection_args, return Result):

1. **p4_shelve(changelist_id: i32, file_paths: Vec<String>, server, user, client)** → Result<String, String>
   - Runs: `p4 shelve -c <cl> [file_paths...]`
   - If file_paths is empty, shelves all files in changelist
   - Returns success message or error

2. **p4_describe_shelved(changelist_id: i32, server, user, client)** → Result<Vec<P4ShelvedFile>, String>
   - Runs: `p4 -ztag describe -S <cl>`
   - Parse indexed ztag fields: depotFile0, action0, type0, rev0, etc. (same pattern as p4_filelog indexed field parsing from D-05-01-01)
   - New struct `P4ShelvedFile { depot_path: String, action: String, file_type: String, revision: i32 }`
   - Returns vector of shelved files

3. **p4_unshelve(changelist_id: i32, server, user, client)** → Result<String, String>
   - Runs: `p4 unshelve -s <cl>`
   - Unshelves all files back to original changelist (per context: no target CL, all-or-nothing)
   - Returns success message or error (including conflict info from stderr)

4. **p4_delete_shelf(changelist_id: i32, server, user, client)** → Result<String, String>
   - Runs: `p4 shelve -d -c <cl>`
   - Deletes all shelved files from changelist
   - Returns success message or error

5. **p4_reconcile_preview(server, user, client)** → Result<Vec<ReconcilePreview>, String>
   - Runs: `p4 reconcile -n` (dry run, entire workspace)
   - New struct `ReconcilePreview { depot_path: String, local_path: String, action: String }`
   - Parse human-readable output line by line: format is `<local_path> - opened for <action>`
   - IMPORTANT: reconcile -n output uses LOCAL paths, not depot paths. The format is:
     `C:\workspace\path\file.txt - opened for edit`
     or `//depot/path/file.txt#1 - opened for add` (for new files)
   - Store whatever path format the line provides in depot_path field; store local_path as empty (UI will handle display)
   - If no changes detected, return empty vec (not error)
   - Stderr may contain "no file(s) to reconcile" — treat as empty result, not error

6. **p4_reconcile_apply(file_paths: Vec<String>, server, user, client)** → Result<String, String>
   - Runs: `p4 reconcile <file_paths...>`
   - Applies reconcile to specific selected paths only
   - Returns success message or error

Register all six commands in src-tauri/src/lib.rs invoke_handler.

Derive Serialize on P4ShelvedFile and ReconcilePreview structs. Follow existing struct patterns (Debug, Clone, Serialize).
  </action>
  <verify>
cargo check in src-tauri directory compiles without errors. All six commands registered in invoke_handler.
  </verify>
  <done>Six Rust commands compile and are registered. P4ShelvedFile and ReconcilePreview structs defined with Serialize.</done>
</task>

<task type="auto">
  <name>Task 2: Add TypeScript invoke wrappers for all six commands</name>
  <files>src/lib/tauri.ts</files>
  <action>
Add six TypeScript invoke wrapper functions to tauri.ts, following the existing pattern (invoke with snake_case command name, pass connection args):

1. **invokeP4Shelve(changelistId: number, filePaths: string[], server?, user?, client?)** → Promise<string>
   - Invokes "p4_shelve" with changelist_id, file_paths, server, user, client

2. **invokeP4DescribeShelved(changelistId: number, server?, user?, client?)** → Promise<P4ShelvedFile[]>
   - Invokes "p4_describe_shelved" with changelist_id
   - Add TypeScript interface: `P4ShelvedFile { depotPath: string; action: string; fileType: string; revision: number; }`

3. **invokeP4Unshelve(changelistId: number, server?, user?, client?)** → Promise<string>
   - Invokes "p4_unshelve" with changelist_id

4. **invokeP4DeleteShelf(changelistId: number, server?, user?, client?)** → Promise<string>
   - Invokes "p4_delete_shelf" with changelist_id

5. **invokeP4ReconcilePreview(server?, user?, client?)** → Promise<ReconcilePreview[]>
   - Invokes "p4_reconcile_preview"
   - Add TypeScript interface: `ReconcilePreview { depotPath: string; localPath: string; action: string; }`

6. **invokeP4ReconcileApply(filePaths: string[], server?, user?, client?)** → Promise<string>
   - Invokes "p4_reconcile_apply" with file_paths

Follow existing camelCase→snake_case arg mapping pattern used by other invoke functions in tauri.ts.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit` passes without errors related to the new functions.
  </verify>
  <done>Six invoke wrappers and two TypeScript interfaces added to tauri.ts. All type-safe with proper arg mapping.</done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` — compiles without errors
2. `npx tsc --noEmit` — TypeScript compiles without errors
3. All six commands appear in invoke_handler in lib.rs
4. P4ShelvedFile and ReconcilePreview types exported from tauri.ts
</verification>

<success_criteria>
- Six Rust commands compile and are registered in Tauri invoke handler
- Six TypeScript invoke wrappers exist with proper type signatures
- P4ShelvedFile and ReconcilePreview interfaces defined in TypeScript
- No compilation errors in Rust or TypeScript
</success_criteria>

<output>
After completion, create `.planning/phases/06-shelve-reconcile/06-01-SUMMARY.md`
</output>
