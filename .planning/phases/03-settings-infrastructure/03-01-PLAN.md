---
phase: 03-settings-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/lib.rs
  - src-tauri/src/commands/p4.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/capabilities/default.json
  - package.json
  - src/lib/settings.ts
  - src/types/settings.ts
  - src/stores/connectionStore.ts
autonomous: true

must_haves:
  truths:
    - "Settings are loaded from tauri-plugin-store on app startup"
    - "Settings are saved to tauri-plugin-store and persist across restarts"
    - "P4 commands use connection args (-p, -u, -c) from saved settings"
    - "User can browse available workspaces for a given server/user"
    - "Connection can be tested before saving settings"
  artifacts:
    - path: "src/types/settings.ts"
      provides: "P4 settings Zod schema and TypeScript types"
      contains: "settingsSchema"
    - path: "src/lib/settings.ts"
      provides: "Load/save settings via tauri-plugin-store"
      exports: ["loadSettings", "saveSettings"]
    - path: "src/stores/connectionStore.ts"
      provides: "Zustand store for connection status (connected/disconnected/error)"
      exports: ["useConnectionStore"]
    - path: "src-tauri/src/commands/p4.rs"
      provides: "p4_list_workspaces and p4_test_connection commands, all commands accept connection args"
      contains: "p4_list_workspaces"
  key_links:
    - from: "src/lib/settings.ts"
      to: "@tauri-apps/plugin-store"
      via: "load() and store.set()/store.get()"
      pattern: "load\\('settings\\.json'"
    - from: "src-tauri/src/commands/p4.rs"
      to: "p4 CLI"
      via: "Command::new with -p, -u, -c args"
      pattern: '"-p".*"-u".*"-c"'
---

<objective>
Set up settings persistence infrastructure and backend commands for Phase 03.

Purpose: Provides the data layer and Rust backend that the settings UI (Plan 02) will consume. Without this, settings can't be stored, connections can't be tested, and workspaces can't be browsed.

Output: tauri-plugin-store integrated, settings types/schema defined, connection store created, Rust commands for workspace listing and connection testing, all existing P4 commands updated to accept optional connection args.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-settings-infrastructure/03-RESEARCH.md

@src-tauri/Cargo.toml
@src-tauri/src/lib.rs
@src-tauri/src/commands/p4.rs
@src-tauri/src/commands/mod.rs
@src-tauri/tauri.conf.json
@src-tauri/capabilities/default.json
@package.json
@src/stores/changelistStore.ts
@src/stores/fileTreeStore.ts
@src/types/p4.ts
@src/lib/tauri.ts
@src/hooks/useP4Command.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and configure tauri-plugin-store</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/lib.rs
    src-tauri/capabilities/default.json
    package.json
  </files>
  <action>
    1. Add `tauri-plugin-store` to Cargo.toml dependencies:
       ```
       tauri-plugin-store = "2"
       ```

    2. Register the store plugin in `src-tauri/src/lib.rs`:
       - Add `.plugin(tauri_plugin_store::Builder::new().build())` to the Tauri builder chain (before `.invoke_handler`)

    3. Add store permission to `src-tauri/capabilities/default.json`:
       - Add `"store:allow-get"`, `"store:allow-set"`, `"store:allow-save"`, `"store:allow-load"` to the permissions array

    4. Install frontend dependencies:
       ```bash
       npm install @tauri-apps/plugin-store react-hook-form zod @hookform/resolvers
       ```

    5. Create `src/types/settings.ts`:
       ```typescript
       import { z } from 'zod';

       export const settingsSchema = z.object({
         p4port: z.string().min(1, 'Server address is required'),
         p4user: z.string().min(1, 'Username is required'),
         p4client: z.string().min(1, 'Workspace is required'),
       });

       export type P4Settings = z.infer<typeof settingsSchema>;

       export const defaultSettings: P4Settings = {
         p4port: '',
         p4user: '',
         p4client: '',
       };
       ```

    6. Create `src/lib/settings.ts`:
       ```typescript
       import { load } from '@tauri-apps/plugin-store';
       import type { P4Settings } from '@/types/settings';
       import { defaultSettings } from '@/types/settings';

       let storeInstance: Awaited<ReturnType<typeof load>> | null = null;

       async function getStore() {
         if (!storeInstance) {
           storeInstance = await load('settings.json', { autoSave: false });
         }
         return storeInstance;
       }

       export async function loadSettings(): Promise<P4Settings> {
         const store = await getStore();
         return {
           p4port: (await store.get<string>('p4port')) || defaultSettings.p4port,
           p4user: (await store.get<string>('p4user')) || defaultSettings.p4user,
           p4client: (await store.get<string>('p4client')) || defaultSettings.p4client,
         };
       }

       export async function saveSettings(settings: P4Settings): Promise<void> {
         const store = await getStore();
         await store.set('p4port', settings.p4port);
         await store.set('p4user', settings.p4user);
         await store.set('p4client', settings.p4client);
         await store.save();
       }
       ```

    7. Create `src/stores/connectionStore.ts`:
       ```typescript
       import { create } from 'zustand';

       interface ConnectionState {
         status: 'connected' | 'disconnected' | 'error' | 'connecting';
         workspace: string | null;
         stream: string | null;
         server: string | null;
         user: string | null;
         errorMessage: string | null;

         setConnecting: () => void;
         setConnected: (info: { workspace: string; stream?: string; server: string; user: string }) => void;
         setDisconnected: () => void;
         setError: (message: string) => void;
       }

       export const useConnectionStore = create<ConnectionState>((set) => ({
         status: 'disconnected',
         workspace: null,
         stream: null,
         server: null,
         user: null,
         errorMessage: null,

         setConnecting: () => set({ status: 'connecting', errorMessage: null }),
         setConnected: ({ workspace, stream, server, user }) => set({
           status: 'connected',
           workspace,
           stream: stream || null,
           server,
           user,
           errorMessage: null,
         }),
         setDisconnected: () => set({
           status: 'disconnected',
           workspace: null,
           stream: null,
           server: null,
           user: null,
           errorMessage: null,
         }),
         setError: (message) => set({
           status: 'error',
           errorMessage: message,
         }),
       }));
       ```
  </action>
  <verify>
    - `npm run build` succeeds (TypeScript compilation passes)
    - `cargo check` in src-tauri succeeds (Rust compilation passes)
    - `src/types/settings.ts`, `src/lib/settings.ts`, `src/stores/connectionStore.ts` all exist
  </verify>
  <done>
    tauri-plugin-store is installed and configured, settings types/schema are defined with Zod, settings load/save functions use Tauri Store API, connection store tracks status with typed state transitions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Rust backend commands for workspace browsing and connection testing</name>
  <files>
    src-tauri/src/commands/p4.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/lib.rs
    src/lib/tauri.ts
  </files>
  <action>
    1. Add `P4Workspace` struct and two new commands to `src-tauri/src/commands/p4.rs`:

       **P4Workspace struct:**
       ```rust
       #[derive(Debug, Clone, Serialize)]
       pub struct P4Workspace {
           pub name: String,
           pub root: String,
           pub stream: Option<String>,
           pub description: String,
       }
       ```

       **p4_list_workspaces command:**
       ```rust
       #[tauri::command]
       pub async fn p4_list_workspaces(server: String, user: String) -> Result<Vec<P4Workspace>, String> {
           let output = Command::new("p4")
               .args(["-p", &server, "-u", &user, "-ztag", "clients", "-u", &user])
               .output()
               .map_err(|e| format!("Failed to execute p4 clients: {}", e))?;

           if !output.status.success() {
               let stderr = String::from_utf8_lossy(&output.stderr);
               return Err(format!("p4 clients failed: {}", stderr));
           }

           let stdout = String::from_utf8_lossy(&output.stdout);
           parse_ztag_clients(&stdout)
       }
       ```

       **parse_ztag_clients function** (follows same pattern as existing parse_ztag_fstat):
       Parse `... client`, `... Root`, `... Stream`, `... Description` fields from -ztag output. Handle records separated by empty lines. Push final record after loop.

       **p4_test_connection command:**
       ```rust
       #[tauri::command]
       pub async fn p4_test_connection(server: String, user: String, client: String) -> Result<P4ClientInfo, String> {
           let output = Command::new("p4")
               .args(["-p", &server, "-u", &user, "-c", &client, "-ztag", "info"])
               .output()
               .map_err(|e| format!("Failed to execute p4 info: {}", e))?;

           if !output.status.success() {
               let stderr = String::from_utf8_lossy(&output.stderr);
               return Err(format!("Connection test failed: {}", stderr));
           }

           // Reuse existing P4ClientInfo parsing logic
           // Parse -ztag info output same as p4_info but with explicit connection args
           // Return P4ClientInfo with clientName, clientRoot, clientStream, userName, serverAddress
       }
       ```
       Extract the existing parsing logic from `p4_info` into a shared `parse_ztag_info` helper function. Both `p4_info` and `p4_test_connection` should call it.

    2. Update existing `p4_info` command to accept optional connection args:
       ```rust
       #[tauri::command]
       pub async fn p4_info(server: Option<String>, user: Option<String>, client: Option<String>) -> Result<P4ClientInfo, String> {
           let mut cmd = Command::new("p4");
           if let Some(s) = &server { cmd.args(["-p", s]); }
           if let Some(u) = &user { cmd.args(["-u", u]); }
           if let Some(c) = &client { cmd.args(["-c", c]); }
           cmd.args(["-ztag", "info"]);
           // ... rest of existing logic
       }
       ```
       Apply same pattern to `p4_fstat`, `p4_opened`, `p4_changes`, `p4_edit`, `p4_revert`, `p4_submit`, `p4_sync` â€” add `server: Option<String>, user: Option<String>, client: Option<String>` params and prepend `-p`/`-u`/`-c` args when present. This ensures all commands respect user-configured settings.

       **IMPORTANT:** For `p4_sync` and `spawn_p4_command` which use `Command::new("p4")`, apply the same pattern: check for optional server/user/client args and prepend them.

    3. Register new commands in `src-tauri/src/lib.rs` invoke_handler:
       Add `commands::p4_list_workspaces` and `commands::p4_test_connection` to the handler array.

    4. Add frontend invoke wrappers in `src/lib/tauri.ts`:
       ```typescript
       export async function invokeListWorkspaces(server: string, user: string) {
         return invoke<P4Workspace[]>('p4_list_workspaces', { server, user });
       }

       export async function invokeTestConnection(server: string, user: string, client: string) {
         return invoke<P4ClientInfo>('p4_test_connection', { server, user, client });
       }
       ```
       Also add the `P4Workspace` type to the frontend types (in `src/types/p4.ts` or inline).

    5. Update all existing frontend `invoke` calls that call p4 commands to pass settings from the connection store. The cleanest approach: create a helper `getConnectionArgs()` in `src/lib/settings.ts` that reads current settings and returns `{ server, user, client }` or `{}` if empty. Update `src/lib/tauri.ts` invoke wrappers to accept and forward optional connection args.

       **NOTE:** Do NOT break existing functionality. If settings are empty (first launch), commands should work without -p/-u/-c args (falling back to environment variables as before).
  </action>
  <verify>
    - `cargo check` in src-tauri succeeds
    - `npm run build` succeeds (TypeScript compiles)
    - New commands `p4_list_workspaces` and `p4_test_connection` are registered in lib.rs
    - Existing commands still compile with new optional params
  </verify>
  <done>
    Rust backend provides p4_list_workspaces and p4_test_connection commands. All existing P4 commands accept optional connection args (-p, -u, -c). Frontend has typed invoke wrappers for new commands. Settings are plumbed through from frontend to backend.
  </done>
</task>

</tasks>

<verification>
- `cargo check` passes in src-tauri (all Rust code compiles)
- `npm run build` passes (all TypeScript compiles)
- tauri-plugin-store is in Cargo.toml dependencies and registered in lib.rs
- settings.json store permissions are in capabilities/default.json
- @tauri-apps/plugin-store, react-hook-form, zod, @hookform/resolvers are in package.json
- src/types/settings.ts exports settingsSchema and P4Settings type
- src/lib/settings.ts exports loadSettings and saveSettings
- src/stores/connectionStore.ts exports useConnectionStore
- p4_list_workspaces and p4_test_connection exist in p4.rs and are registered
- All existing p4 commands accept optional server/user/client params
</verification>

<success_criteria>
Settings infrastructure is fully implemented: persistence layer (tauri-plugin-store), types (Zod schema), connection state management (Zustand), and backend commands (workspace browsing, connection testing, all commands accept connection args). Plan 02 can build the UI on top of this foundation.
</success_criteria>

<output>
After completion, create `.planning/phases/03-settings-infrastructure/03-01-SUMMARY.md`
</output>
