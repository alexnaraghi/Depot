---
phase: 23-fileindex-and-search
plan: 03
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - src/hooks/useFileTree.ts
  - src-tauri/src/commands/p4/p4handlers.rs
autonomous: true

must_haves:
  truths:
    - "FileIndex rebuilds automatically when streaming fstat completes"
    - "Index is populated incrementally as fstat batches arrive"
    - "Index clears when workspace changes before new fstat stream starts"
    - "Search is queryable as soon as first batch arrives (not waiting for full load)"
  artifacts:
    - path: "src/hooks/useFileTree.ts"
      provides: "Streaming integration that populates FileIndex"
      contains: "addFilesToIndex"
  key_links:
    - from: "src/hooks/useFileTree.ts"
      to: "add_files_to_index"
      via: "Tauri invoke on batch"
      pattern: "addFilesToIndex"
    - from: "src/hooks/useFileTree.ts"
      to: "clear_file_index"
      via: "Tauri invoke on stream start"
      pattern: "clearFileIndex"
---

<objective>
Integrate FileIndex population with the streaming fstat workflow so the index rebuilds automatically.

Purpose: The index must stay current with workspace data. By populating the index as fstat batches arrive, search becomes usable immediately (first batch ~500ms) rather than waiting for the full workspace load.

Output: FileIndex automatically populated during streaming fstat, clears on workspace change.
</objective>

<execution_context>
@C:\Users\a\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\a\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-fileindex-and-search/23-RESEARCH.md
@.planning/phases/23-fileindex-and-search/23-01-SUMMARY.md

# Existing streaming implementation
@src/hooks/useFileTree.ts
@src-tauri/src/commands/p4/p4handlers.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update useFileTree to populate FileIndex during streaming</name>
  <files>
    src/hooks/useFileTree.ts
  </files>
  <action>
Update useFileTree.ts to populate the FileIndex as streaming fstat batches arrive:

1. Import the index management functions:
   ```typescript
   import { addFilesToIndex, clearFileIndex } from '@/hooks/useFileSearch';
   ```

2. Find the streaming fstat batch handler (should be in the Channel listener).
   When a batch is received, also add files to the index:

   ```typescript
   // In the batch handler where files are processed:
   if (batch.type === 'data') {
     // Existing code to update query cache with files...

     // Also populate FileIndex incrementally
     const indexEntries = batch.files.map(file => ({
       depotPath: file.depotPath,
       // P4 fstat doesn't return modification time directly in the current types
       // Use 0 for now - we'll enhance this if modTime is available
       modTime: 0,
     }));

     // Fire-and-forget - don't await to avoid blocking batch processing
     addFilesToIndex(indexEntries).catch(err => {
       console.warn('Failed to add files to index:', err);
     });
   }
   ```

3. Clear the index when starting a new fstat stream:
   Before calling p4_fstat_stream (or at the start of the streaming effect), clear the index:

   ```typescript
   // Before starting stream:
   clearFileIndex().catch(err => {
     console.warn('Failed to clear file index:', err);
   });
   ```

4. The index should also clear when the workspace changes. Look for workspace change
   handling (likely in useEffect dependencies on workspace/connection settings).
   If there's a workspace change effect, add clearFileIndex() call there too.

5. Note: The P4FileInfo type may not have modTime. Check the type definition.
   If it's not available, use 0 as a placeholder. The recency bias feature
   will be limited but search will still work. We can enhance P4FileInfo
   and fstat parsing in a future iteration if needed.

6. If the streaming is handled differently (e.g., through TanStack Query's
   streaming support), adapt the approach but the key points remain:
   - Clear index at stream start
   - Add files to index on each batch
   - Don't await the index operations (fire-and-forget for performance)
  </action>
  <verify>
    Run `npm run typecheck` - should pass.
    Run `npm run tauri dev` and test:
    1. Open a workspace - should see files loading progressively
    2. Start typing in filter while files are still loading - should get results from already-loaded files
    3. Switch workspaces - index should clear and rebuild for new workspace
  </verify>
  <done>
    FileIndex clears when streaming fstat starts.
    FileIndex populates incrementally as batches arrive.
    Search works immediately after first batch (not waiting for full load).
    No blocking on index operations (fire-and-forget pattern).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add modTime extraction from fstat for recency bias</name>
  <files>
    src-tauri/src/commands/p4/types.rs
    src-tauri/src/commands/p4/p4handlers.rs
  </files>
  <action>
Enhance P4FileInfo to include modification time for recency bias:

1. Update P4FileInfo in types.rs to add head_mod_time:
   ```rust
   #[derive(Debug, Clone, Serialize)]
   pub struct P4FileInfo {
       pub depot_path: String,
       pub local_path: String,
       pub status: String,
       pub action: Option<String>,
       pub revision: i32,
       pub head_revision: i32,
       pub changelist: Option<i32>,
       pub file_type: String,
       pub head_action: Option<String>,
       pub head_mod_time: Option<i64>,  // ADD THIS - Unix timestamp of head revision
   }
   ```

2. Update build_file_info in p4handlers.rs to extract headModTime:
   Find the build_file_info function and add parsing for headModTime:

   ```rust
   // In build_file_info function, add:
   let head_mod_time = record.get("headModTime")
       .and_then(|s| s.parse::<i64>().ok());
   ```

   And include it in the P4FileInfo struct construction:
   ```rust
   Some(P4FileInfo {
       depot_path,
       local_path,
       status,
       action,
       revision,
       head_revision,
       changelist,
       file_type,
       head_action,
       head_mod_time,  // ADD THIS
   })
   ```

3. The headModTime field from p4 fstat -ztag is in Unix epoch seconds format.
   This matches what FileIndex expects for recency calculation.

4. Update the frontend to pass modTime when adding to index.
   In useFileTree.ts, update the batch handler:
   ```typescript
   const indexEntries = batch.files.map(file => ({
     depotPath: file.depotPath,
     modTime: file.headModTime ?? 0,  // Use actual mod time if available
   }));
   ```
  </action>
  <verify>
    Run `cd C:\Projects\Fun\p4now\src-tauri && cargo check` - should compile.
    Run `npm run typecheck` - should pass.
    Run `npm run tauri dev` and test:
    1. Open workspace
    2. Search for a file that was recently modified
    3. The recently modified file should rank higher than older files with similar names
  </verify>
  <done>
    P4FileInfo includes headModTime field.
    Fstat parsing extracts headModTime from p4 output.
    Frontend passes modTime to FileIndex.
    Recency bias works - recently modified files rank higher.
  </done>
</task>

</tasks>

<verification>
1. TypeScript and Rust compile without errors
2. FileIndex populated during streaming fstat
3. Index clears on workspace change
4. Search works during loading (partial results from loaded batches)
5. Recency bias functional (recent files rank higher)
</verification>

<success_criteria>
- FileIndex clears when new fstat stream starts
- FileIndex populates incrementally as batches arrive
- P4FileInfo has headModTime field populated from fstat output
- Frontend passes modTime to index for recency bias
- Search returns results immediately after first batch loads
- Recency bias works - recently modified files score higher
</success_criteria>

<output>
After completion, create `.planning/phases/23-fileindex-and-search/23-03-SUMMARY.md`
</output>
