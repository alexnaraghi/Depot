---
phase: 14-depot-browser
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/commands/p4.rs
  - src-tauri/src/lib.rs
  - src/lib/tauri.ts
autonomous: true

must_haves:
  truths:
    - "p4_dirs command returns immediate subdirectories for a depot path"
    - "p4_depots command returns all depot roots with name and type"
    - "Frontend can invoke both commands via typed async functions"
  artifacts:
    - path: "src-tauri/src/commands/p4.rs"
      provides: "p4_dirs and p4_depots Tauri commands"
      contains: "pub async fn p4_dirs"
    - path: "src/lib/tauri.ts"
      provides: "invokeP4Dirs and invokeP4Depots wrapper functions"
      contains: "invokeP4Dirs"
  key_links:
    - from: "src/lib/tauri.ts"
      to: "src-tauri/src/commands/p4.rs"
      via: "Tauri invoke bridge"
      pattern: "invoke.*p4_dirs"
---

<objective>
Add Rust backend commands for depot browsing (`p4 dirs` and `p4 depots`) and their TypeScript invoke wrappers.

Purpose: Provides the data layer for the depot browser — without these commands, the frontend cannot list depot roots or browse subdirectories.
Output: Two new Tauri commands registered and callable from frontend.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-depot-browser/14-RESEARCH.md

@src-tauri/src/commands/p4.rs (pattern: see p4_list_streams for command structure)
@src-tauri/src/lib.rs (register new commands in invoke_handler)
@src/lib/tauri.ts (pattern: see invokeListWorkspaces for wrapper structure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add p4_dirs and p4_depots Rust commands</name>
  <files>src-tauri/src/commands/p4.rs, src-tauri/src/lib.rs</files>
  <action>
Add two new Tauri commands at the end of `src-tauri/src/commands/p4.rs`:

**p4_depots:** Lists all depot roots.
- Signature: `pub async fn p4_depots(server: Option<String>, user: Option<String>) -> Result<Vec<P4Depot>, String>`
- Define `P4Depot` struct with `name: String`, `depot_type: String` (derive Debug, Clone, Serialize)
- Run `p4 -ztag depots` with connection args via `apply_connection_args`
- Parse `-ztag` output: extract `name` from `... name <value>` lines, `type` from `... Type <value>` lines
- Group by record (records separated by blank lines or by seeing `... name` again)
- Return Vec of P4Depot

**p4_dirs:** Lists immediate subdirectories of a depot path.
- Signature: `pub async fn p4_dirs(depot_path: String, include_deleted: bool, server: Option<String>, user: Option<String>, client: Option<String>) -> Result<Vec<String>, String>`
- Run `p4 -ztag dirs [-D] <depot_path>` with connection args
- If `include_deleted` is true, add `-D` flag before `dirs`
- Parse `-ztag` output: extract values from `... dir <path>` lines
- Return Vec of depot paths (strings like `//depot/folder`)
- Handle empty results gracefully (return empty vec, not error)
- Handle stderr errors (e.g., "no such file(s)") — return empty vec for "no such file" errors, propagate real errors

Register both commands in `src-tauri/src/lib.rs` invoke_handler array: add `commands::p4_dirs` and `commands::p4_depots` after `commands::p4_update_client_stream`.
  </action>
  <verify>Run `cargo check --manifest-path src-tauri/Cargo.toml` — should compile without errors.</verify>
  <done>Both p4_dirs and p4_depots commands compile and are registered in invoke_handler.</done>
</task>

<task type="auto">
  <name>Task 2: Add TypeScript invoke wrappers and types</name>
  <files>src/lib/tauri.ts</files>
  <action>
Add to `src/lib/tauri.ts`:

1. **P4Depot interface:**
```typescript
export interface P4Depot {
  name: string;
  depot_type: string;
}
```

2. **invokeP4Depots function** (follow invokeListWorkspaces pattern):
```typescript
export async function invokeP4Depots(server?: string, user?: string): Promise<P4Depot[]> {
  return invoke<P4Depot[]>('p4_depots', { server, user });
}
```

3. **invokeP4Dirs function:**
```typescript
export async function invokeP4Dirs(depotPath: string, includeDeleted: boolean = false, server?: string, user?: string, client?: string): Promise<string[]> {
  return invoke<string[]>('p4_dirs', { depotPath, includeDeleted, server, user, client });
}
```

Place these near the other invoke functions (after invokeP4UpdateClientStream or at the end of the file).
  </action>
  <verify>Run `npx tsc --noEmit` — should compile without errors.</verify>
  <done>invokeP4Dirs and invokeP4Depots are exported from tauri.ts with proper types.</done>
</task>

</tasks>

<verification>
1. `cargo check --manifest-path src-tauri/Cargo.toml` passes
2. `npx tsc --noEmit` passes
3. Both new commands visible in lib.rs invoke_handler
4. Both invoke wrappers exported from tauri.ts
</verification>

<success_criteria>
- p4_dirs Rust command parses -ztag output and returns directory paths
- p4_depots Rust command returns depot names and types
- TypeScript wrappers match Rust signatures (camelCase -> snake_case conversion)
- No compilation errors in either Rust or TypeScript
</success_criteria>

<output>
After completion, create `.planning/phases/14-depot-browser/14-01-SUMMARY.md`
</output>
