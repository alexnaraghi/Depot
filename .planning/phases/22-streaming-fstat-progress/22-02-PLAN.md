---
phase: 22-streaming-fstat-progress
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - src/lib/tauri.ts
  - src/components/FileTree/useFileTree.ts
autonomous: true

must_haves:
  truths:
    - "Frontend receives streaming batches via Tauri Channel callback"
    - "File tree updates incrementally as batches arrive (not all-or-nothing)"
    - "User can cancel streaming load and partial results remain visible"
    - "Query cache accumulates files without full replacement per batch"
  artifacts:
    - path: "src/lib/tauri.ts"
      provides: "invokeP4FstatStream function and FstatStreamBatch type"
      contains: "invokeP4FstatStream"
    - path: "src/components/FileTree/useFileTree.ts"
      provides: "Streaming fstat integration with batch accumulation"
      contains: "invokeP4FstatStream"
  key_links:
    - from: "useFileTree.ts"
      to: "tauri.ts:invokeP4FstatStream"
      via: "invoke with onBatch callback"
      pattern: "invokeP4FstatStream"
    - from: "useFileTree.ts"
      to: "operation.ts:useOperationStore"
      via: "startOperation, setProcessId"
      pattern: "useOperationStore"
---

<objective>
Integrate streaming fstat into frontend with progressive file tree updates.

Purpose: Replace blocking invokeP4Fstat with streaming invokeP4FstatStream. File tree populates incrementally as batches arrive, users see files within 500ms instead of waiting 5-15 seconds for complete load.

Output: useFileTree hook that streams fstat data, accumulates batches into query cache, integrates with operation store for progress/cancellation.
</objective>

<execution_context>
@C:\Users\a\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\a\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-streaming-fstat-progress/22-RESEARCH.md
@.planning/phases/22-streaming-fstat-progress/22-01-SUMMARY.md
@src/lib/tauri.ts (invokeP4Sync streaming pattern, lines 180-188)
@src/hooks/useSync.ts (frontend streaming pattern)
@src/components/FileTree/useFileTree.ts (current blocking implementation)
@src/store/operation.ts (operation store interface)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add streaming fstat types and invoke wrapper to tauri.ts</name>
  <files>src/lib/tauri.ts</files>
  <action>
Add TypeScript types and invoke wrapper for streaming fstat, following the invokeP4Sync pattern.

1. Add the FstatStreamBatch discriminated union type (after SyncProgress interface, around line 56):

```typescript
/**
 * Streaming batch from p4_fstat_stream
 * type: "data" contains file batches
 * type: "complete" signals end of stream
 */
export type FstatStreamBatch =
  | { type: 'data'; files: P4FileInfo[]; totalReceived: number }
  | { type: 'complete'; totalFiles: number; success: boolean; error?: string };
```

2. Add the streaming invoke function (after invokeP4Fstat, around line 131):

```typescript
/**
 * Stream file status for workspace files with batched progress.
 * Use for large workspaces where all-or-nothing loading causes UI freeze.
 * @param paths - Specific paths to query, or empty for all workspace files
 * @param depotPath - Depot path to query (e.g., "//stream/main/...") when paths is empty
 * @param onBatch - Callback for streaming batches (data + completion signal)
 * @returns Process ID for cancellation
 */
export async function invokeP4FstatStream(
  paths: string[],
  depotPath: string | undefined,
  onBatch: (batch: FstatStreamBatch) => void
): Promise<string> {
  const channel = new Channel<FstatStreamBatch>();
  channel.onmessage = onBatch;
  return invoke<string>('p4_fstat_stream', {
    paths,
    depotPath,
    ...getConnectionArgs(),
    onBatch: channel,
  });
}
```
  </action>
  <verify>Run `npm run typecheck` to verify TypeScript compiles</verify>
  <done>FstatStreamBatch type and invokeP4FstatStream function exist in tauri.ts</done>
</task>

<task type="auto">
  <name>Task 2: Refactor useFileTree to use streaming with batch accumulation</name>
  <files>src/components/FileTree/useFileTree.ts</files>
  <action>
Refactor useFileTree to use streaming fstat with progressive updates.

Key changes:
1. Add streaming state (isStreaming flag, accumulated files ref)
2. Replace invokeP4Fstat with invokeP4FstatStream in queryFn
3. Accumulate batches via setQueryData with structuralSharing: false
4. Integrate with operation store for progress tracking
5. Handle completion signal to finalize loading state

Replace the workspace files query (around lines 104-129) with streaming implementation:

```typescript
import { useCallback, useMemo, useEffect, useRef, useState } from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useFileTreeStore } from '@/stores/fileTreeStore';
import { useConnectionStore } from '@/stores/connectionStore';
import { invokeP4FstatStream, invokeP4Info, P4FileInfo, FstatStreamBatch } from '@/lib/tauri';
import { useOperationStore } from '@/store/operation';
import { getVerboseLogging } from '@/lib/settings';
import { buildFileTree } from '@/utils/treeBuilder';
import { P4File, FileStatus, FileAction } from '@/types/p4';

// ... keep mapP4FileInfo function unchanged ...

/**
 * Hook for loading and managing file tree data
 *
 * Fetches workspace files from P4 using streaming for progressive loading.
 * Updates store and builds hierarchical tree structure incrementally.
 *
 * Uses TanStack Query for caching with streaming accumulation.
 */
export function useFileTree() {
  const queryClient = useQueryClient();
  const { rootPath, setFiles, setLoading, setRootPath } = useFileTreeStore();
  const { status, p4port, p4user, p4client } = useConnectionStore();
  const {
    startOperation,
    updateProgress,
    updateMessage,
    setProcessId,
    completeOperation,
    addOutputLine,
    currentOperation,
  } = useOperationStore();
  const isConnected = status === 'connected';

  // Streaming state
  const [isStreaming, setIsStreaming] = useState(false);
  const accumulatedFilesRef = useRef<P4File[]>([]);
  const estimatedTotalRef = useRef(0);

  // ... keep useEffect for clearing store when disconnected ...
  // ... keep clientInfo query unchanged ...
  // ... keep useEffect for setting rootPath unchanged ...

  // Build depot path for querying
  const depotPath = clientInfo?.client_stream
    ? `${clientInfo.client_stream}/...`
    : undefined;

  // Streaming fstat loader
  const loadFilesStreaming = useCallback(async () => {
    if (!rootPath || !depotPath) return [];
    if (isStreaming) return []; // Prevent concurrent streams

    const operationId = `fstat-${Date.now()}`;
    startOperation(operationId, 'fstat');
    setIsStreaming(true);
    setLoading(true);
    accumulatedFilesRef.current = [];
    estimatedTotalRef.current = 0;

    const verbose = await getVerboseLogging();
    if (verbose) addOutputLine(`p4 fstat ${depotPath} (streaming)`, false);

    return new Promise<P4File[]>((resolve, reject) => {
      invokeP4FstatStream([], depotPath, (batch: FstatStreamBatch) => {
        if (batch.type === 'data') {
          // Map backend types to frontend types
          const mappedBatch = batch.files.map(mapP4FileInfo);
          accumulatedFilesRef.current.push(...mappedBatch);

          // Update estimate: first batch sets baseline, subsequent batches refine
          if (estimatedTotalRef.current === 0) {
            // Conservative estimate: assume first batch is 10% of total
            estimatedTotalRef.current = batch.files.length * 10;
          } else if (batch.totalReceived > estimatedTotalRef.current * 0.9) {
            // Approaching estimate, increase it
            estimatedTotalRef.current = Math.floor(batch.totalReceived * 1.1);
          }

          // Update progress (capped at 99% until completion)
          const progress = Math.min(
            Math.round((batch.totalReceived / estimatedTotalRef.current) * 100),
            99
          );
          updateProgress(progress, `Loading files... (${batch.totalReceived})`);

          // Update query cache incrementally with structuralSharing: false
          // to prevent reference breaks that cause full tree re-renders
          queryClient.setQueryData(
            ['fileTree', rootPath, depotPath],
            [...accumulatedFilesRef.current],
            { structuralSharing: false }
          );

          // Update store for components that use it directly
          setFiles(accumulatedFilesRef.current);

        } else if (batch.type === 'complete') {
          if (verbose) {
            addOutputLine(`... returned ${batch.totalFiles} items`, false);
          }

          if (batch.success) {
            completeOperation(true);
            resolve(accumulatedFilesRef.current);
          } else {
            completeOperation(false, batch.error ?? 'Unknown error');
            reject(new Error(batch.error ?? 'Streaming failed'));
          }

          setIsStreaming(false);
          setLoading(false);
        }
      })
        .then((processId) => {
          setProcessId(processId);
        })
        .catch((err) => {
          completeOperation(false, String(err));
          setIsStreaming(false);
          setLoading(false);
          reject(err);
        });
    });
  }, [
    rootPath,
    depotPath,
    isStreaming,
    startOperation,
    setLoading,
    addOutputLine,
    updateProgress,
    queryClient,
    setFiles,
    completeOperation,
    setProcessId,
  ]);

  // Query for workspace files using streaming
  const { data: files = [], isLoading: filesLoading, error: filesError, refetch } = useQuery({
    queryKey: ['fileTree', rootPath, depotPath],
    queryFn: loadFilesStreaming,
    enabled: rootPath !== null && !isStreaming, // Disable during active streaming
    staleTime: 30000,
    refetchOnWindowFocus: false, // Disable auto-refetch during potential streaming
    structuralSharing: false, // Prevent reference breaks from streaming updates
  });

  const isLoading = clientInfoLoading || filesLoading || isStreaming;
  const error = clientInfoError || filesError;

  // Build tree structure from flat file list
  const tree = useMemo(() => {
    if (!rootPath || files.length === 0) {
      return [];
    }
    return buildFileTree(files, rootPath);
  }, [files, rootPath]);

  return {
    tree,
    files,
    isLoading,
    isStreaming,
    error,
    refetch,
  };
}
```

IMPORTANT: Keep the existing mapP4FileInfo function, clientInfo query, and useEffect hooks unchanged. Only replace the file loading logic.
  </action>
  <verify>Run `npm run typecheck` and `npm run build` to verify compilation</verify>
  <done>useFileTree uses streaming fstat with batch accumulation and operation store integration</done>
</task>

</tasks>

<verification>
Run the following checks:
1. `npm run typecheck` - Verify TypeScript compiles
2. `npm run build` - Verify full build succeeds
3. Manual test: Open app with connected workspace, observe files appearing progressively
4. Manual test: During loading, status bar shows progress and file count
</verification>

<success_criteria>
- FstatStreamBatch type defined in tauri.ts
- invokeP4FstatStream function exists and uses Channel pattern
- useFileTree accumulates batches via setQueryData with structuralSharing: false
- Operation store integration (startOperation, updateProgress, setProcessId, completeOperation)
- isStreaming state prevents concurrent streams
- Query refetch disabled during active streaming
</success_criteria>

<output>
After completion, create `.planning/phases/22-streaming-fstat-progress/22-02-SUMMARY.md`
</output>
